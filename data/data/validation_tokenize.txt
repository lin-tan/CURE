if ( cut CaMeL Action != null ) cut CaMeL Action . add CaMeL Property CaMeL Change CaMeL Listener ( cut CaMeL Action CaMeL Listener ) ; <CTX> public void set CaMeL Cut CaMeL Action ( I CaMeL Action action ) { if ( cut CaMeL Action == action ) return ; if ( cut CaMeL Action != null ) cut CaMeL Action . remove CaMeL Property CaMeL Change CaMeL Listener ( cut CaMeL Action CaMeL Listener ) ; cut CaMeL Action = action ; if ( cut CaMeL Action != null ) cut CaMeL Action . add CaMeL Property CaMeL Change CaMeL Listener ( cut CaMeL Action CaMeL Listener ) ; cell CaMeL Cut CaMeL Action . update CaMeL Enabled CaMeL State ( ) ; }	if ( cut CaMeL Action != null ) { cut CaMeL Action . add CaMeL Property CaMeL Change CaMeL Listener ( cut CaMeL Action CaMeL Listener ) ; }
errors . add ( field . get CaMeL Key ( ) , Resources . get CaMeL Action CaMeL Message ( request , va , field ) ) ; <CTX> public static Object validate CaMeL Short ( Object bean , Validator CaMeL Action va , Field field , Action CaMeL Messages errors , Http CaMeL Servlet CaMeL Request request ) { Object result = null ; String value = null ; if ( is CaMeL String ( bean ) ) { value = ( String ) bean ; } else { value = Validator CaMeL Utils . get CaMeL Value CaMeL As CaMeL String ( bean , field . get CaMeL Property ( ) ) ; } if ( Generic CaMeL Validator . is CaMeL Blank CaMeL Or CaMeL Null ( value ) ) { return Boolean . TRUE ; } result = Generic CaMeL Type CaMeL Validator . format CaMeL Short ( value ) ; if ( result == null ) { errors . add ( field . get CaMeL Key ( ) , Resources . get CaMeL Action CaMeL Message ( request , va , field ) ) ; } return result == null ? Boolean . FALSE : result ; }	errors . add ( field . get CaMeL Key ( ) , Resources . get CaMeL Action CaMeL Message ( validator , request , va , field ) ) ;
i CaMeL Visited . accept ( _ Payload ) ; <CTX> public void visit CaMeL Op CaMeL Asgn CaMeL Or CaMeL Node ( Op CaMeL Asgn CaMeL Or CaMeL Node i CaMeL Visited ) { i CaMeL Visited . accept ( _ Payload ) ; }	_ Payload . visit CaMeL Op CaMeL Asgn CaMeL Or CaMeL Node ( i CaMeL Visited ) ;
return new Local CaMeL Quick CaMeL Fix [ 0 ] ; <CTX> private static Local CaMeL Quick CaMeL Fix [ ] get CaMeL Quick CaMeL Fixes ( final Generic CaMeL Dom CaMeL Value element ) { final Converter converter = element . get CaMeL Converter ( ) ; if ( converter instanceof Resolving CaMeL Converter ) { final Resolving CaMeL Converter resolving CaMeL Converter = ( Resolving CaMeL Converter ) converter ; return resolving CaMeL Converter . get CaMeL Quick CaMeL Fixes ( new Convert CaMeL Context CaMeL Impl ( Dom CaMeL Manager CaMeL Impl . get CaMeL Dom CaMeL Invocation CaMeL Handler ( element ) ) ) ; } return new Local CaMeL Quick CaMeL Fix [ 0 ] ; }	if ( reference instanceof Local CaMeL Quick CaMeL Fix CaMeL Provider ) { result . add CaMeL All ( Arrays . as CaMeL List ( ( ( Local CaMeL Quick CaMeL Fix CaMeL Provider ) reference ) . get CaMeL Quick CaMeL Fixes ( ) ) ) ; } return result . to CaMeL Array ( new Local CaMeL Quick CaMeL Fix [ result . size ( ) ] ) ;
Array CaMeL List others CaMeL List = new Array CaMeL List ( Arrays . as CaMeL List ( page . get CaMeL Editor CaMeL References ( ) ) ) ; if ( others CaMeL List . is CaMeL Empty ( ) ) { return null ; } I CaMeL Editor CaMeL Reference active = page . get CaMeL Active CaMeL Editor CaMeL Reference ( ) ; if ( active != null ) { others CaMeL List . remove ( active ) ; Array CaMeL List active CaMeL List = new Array CaMeL List ( 1 ) ; active CaMeL List . add ( active ) ; I CaMeL Editor CaMeL Part match = find CaMeL Editor ( input , active CaMeL List ) ; if ( match != null ) { return match ; } } return find CaMeL Editor ( input , others CaMeL List ) ; <CTX> public I CaMeL Editor CaMeL Part find CaMeL Editor ( I CaMeL Editor CaMeL Input input ) { Array CaMeL List others CaMeL List = new Array CaMeL List ( Arrays . as CaMeL List ( page . get CaMeL Editor CaMeL References ( ) ) ) ; if ( others CaMeL List . is CaMeL Empty ( ) ) { return null ; } I CaMeL Editor CaMeL Reference active = page . get CaMeL Active CaMeL Editor CaMeL Reference ( ) ; if ( active != null ) { others CaMeL List . remove ( active ) ; Array CaMeL List active CaMeL List = new Array CaMeL List ( 1 ) ; active CaMeL List . add ( active ) ; I CaMeL Editor CaMeL Part match = find CaMeL Editor ( input , active CaMeL List ) ; if ( match != null ) { return match ; } } return find CaMeL Editor ( input , others CaMeL List ) ; }	return find CaMeL Editor ( null , input , Workbench CaMeL Page . MATCH _ INPUT ) ;
return context . declaration . get CaMeL Extractor ( ) . get CaMeL Boolean CaMeL Value ( left ) == ( ( Boolean CaMeL Variable CaMeL Context CaMeL Entry ) context ) . right ; <CTX> public boolean evaluate CaMeL Cached CaMeL Right ( final Variable CaMeL Context CaMeL Entry context , final Object left ) { return context . declaration . get CaMeL Extractor ( ) . get CaMeL Boolean CaMeL Value ( left ) == ( ( Boolean CaMeL Variable CaMeL Context CaMeL Entry ) context ) . right ; }	return context . get CaMeL Variable CaMeL Declaration ( ) . get CaMeL Extractor ( ) . get CaMeL Boolean CaMeL Value ( left ) == ( ( Boolean CaMeL Variable CaMeL Context CaMeL Entry ) context ) . right ;
int min = calculate CaMeL Max CaMeL Tab CaMeL Width ( tab CaMeL Placement ) ; width = Math . max ( min , width ) ; int tab CaMeL Area CaMeL Height = preferred CaMeL Tab CaMeL Area CaMeL Height ( tab CaMeL Placement , width - tab CaMeL Area CaMeL Insets . left - tab CaMeL Area CaMeL Insets . right ) ; height += tab CaMeL Area CaMeL Height ; <CTX> protected Dimension calculate CaMeL Size ( boolean minimum ) { int tab CaMeL Placement = tab CaMeL Pane . get CaMeL Tab CaMeL Placement ( ) ; int width = 0 ; int height = 0 ; Component c ; Dimension dims ; / / Find out the minimum / preferred size to display the largest child / / of the tabbed pane . for ( int i = 0 ; i < tab CaMeL Pane . get CaMeL Tab CaMeL Count ( ) ; i ++ ) { c = tab CaMeL Pane . get CaMeL Component CaMeL At ( i ) ; if ( c == null ) continue ; dims = minimum ? c . get CaMeL Minimum CaMeL Size ( ) : c . get CaMeL Preferred CaMeL Size ( ) ; if ( dims != null ) { height = Math . max ( height , dims . height ) ; width = Math . max ( width , dims . width ) ; } } Insets tab CaMeL Area CaMeL Insets = get CaMeL Tab CaMeL Area CaMeL Insets ( tab CaMeL Placement ) ; if ( tab CaMeL Placement == Swing CaMeL Constants . TOP || tab CaMeL Placement == Swing CaMeL Constants . BOTTOM ) { int min = calculate CaMeL Max CaMeL Tab CaMeL Width ( tab CaMeL Placement ) ; width = Math . max ( min , width ) ; int tab CaMeL Area CaMeL Height = preferred CaMeL Tab CaMeL Area CaMeL Height ( tab CaMeL Placement , width - tab CaMeL Area CaMeL Insets . left - tab CaMeL Area CaMeL Insets . right ) ; height += tab CaMeL Area CaMeL Height ; } else { int min = calculate CaMeL Max CaMeL Tab CaMeL Height ( tab CaMeL Placement ) ; height = Math . max ( min , height ) ; int tab CaMeL Area CaMeL Width = preferred CaMeL Tab CaMeL Area CaMeL Width ( tab CaMeL Placement , height - tab CaMeL Area CaMeL Insets . top - tab CaMeL Area CaMeL Insets . bottom ) ; width += tab CaMeL Area CaMeL Width ; } Insets tab CaMeL Pane CaMeL Insets = tab CaMeL Pane . get CaMeL Insets ( ) ; return new Dimension ( width + tab CaMeL Pane CaMeL Insets . left + tab CaMeL Pane CaMeL Insets . right , height + tab CaMeL Pane CaMeL Insets . top + tab CaMeL Pane CaMeL Insets . bottom ) ; }	width = Math . max ( calculate CaMeL Max CaMeL Tab CaMeL Width ( tab CaMeL Placement ) , width ) ; height += preferred CaMeL Tab CaMeL Area CaMeL Height ( tab CaMeL Placement , width - tab CaMeL Area CaMeL Insets . left - tab CaMeL Area CaMeL Insets . right ) ;
j CaMeL Menu CaMeL Item CaMeL New CaMeL Project CaMeL Action CaMeL Performed ( evt ) ; <CTX> public void action CaMeL Performed ( java . awt . event . Action CaMeL Event evt ) { j CaMeL Menu CaMeL Item CaMeL New CaMeL Project CaMeL Action CaMeL Performed ( evt ) ; }	j CaMeL Check CaMeL Box CaMeL Toggle CaMeL Fullscreen CaMeL Action CaMeL Performed ( evt ) ;
if ( index >= 0 ) <CTX> public void bundle CaMeL Changed ( Bundle CaMeL Event event ) { int event CaMeL Type = event . get CaMeL Type ( ) ; String bundle CaMeL Name ; synchronized ( this ) { if ( event CaMeL Type == Bundle CaMeL Event . STARTING ) { starting . add ( bundle CaMeL Name = event . get CaMeL Bundle ( ) . get CaMeL Symbolic CaMeL Name ( ) ) ; } else if ( event CaMeL Type == Bundle CaMeL Event . STARTED ) { progress CaMeL Count ++ ; if ( progress CaMeL Count <= maximum CaMeL Progress CaMeL Count ) progress CaMeL Monitor . worked ( 1 ) ; int index = starting . last CaMeL Index CaMeL Of ( event . get CaMeL Bundle ( ) . get CaMeL Symbolic CaMeL Name ( ) ) ; if ( index >= 0 ) starting . remove ( index ) ; if ( index != starting . size ( ) ) return ; / / not currently displayed bundle CaMeL Name = index == 0 ? null : ( String ) starting . get ( index - 1 ) ; } else { return ; / / uninteresting event } } String task CaMeL Name ; if ( bundle CaMeL Name == null ) task CaMeL Name = Workbench CaMeL Messages . Startup _ Loading _ Workbench ; else task CaMeL Name = NLS . bind ( Workbench CaMeL Messages . Startup _ Loading , bundle CaMeL Name ) ; progress CaMeL Monitor . sub CaMeL Task ( task CaMeL Name ) ; }	if ( index >= 0 ) {
String new CaMeL Str = get CaMeL Squeeze ( args ) ; if ( new CaMeL Str . equals ( get CaMeL Value ( ) ) ) { <CTX> public I CaMeL Ruby CaMeL Object squeeze _ bang ( I CaMeL Ruby CaMeL Object [ ] args ) { String new CaMeL Str = get CaMeL Squeeze ( args ) ; if ( new CaMeL Str . equals ( get CaMeL Value ( ) ) ) { return get CaMeL Runtime ( ) . get CaMeL Nil ( ) ; } set CaMeL Value ( new CaMeL Str ) ; return this ; }	String CaMeL Buffer new CaMeL Str = get CaMeL Squeeze ( args ) ; if ( same CaMeL As ( new CaMeL Str ) ) {
switch ( evt . get CaMeL ID ( ) ) { case Window CaMeL Event . WINDOW _ ACTIVATED : window CaMeL Listener . window CaMeL Activated ( evt ) ; break ; case Window CaMeL Event . WINDOW _ CLOSED : window CaMeL Listener . window CaMeL Closed ( evt ) ; break ; case Window CaMeL Event . WINDOW _ CLOSING : window CaMeL Listener . window CaMeL Closing ( evt ) ; break ; case Window CaMeL Event . WINDOW _ DEACTIVATED : window CaMeL Listener . window CaMeL Deactivated ( evt ) ; break ; case Window CaMeL Event . WINDOW _ DEICONIFIED : window CaMeL Listener . window CaMeL Deiconified ( evt ) ; break ; case Window CaMeL Event . WINDOW _ ICONIFIED : window CaMeL Listener . window CaMeL Iconified ( evt ) ; break ; case Window CaMeL Event . WINDOW _ OPENED : window CaMeL Listener . window CaMeL Opened ( evt ) ; break ; case Window CaMeL Event . WINDOW _ GAINED _ FOCUS : case Window CaMeL Event . WINDOW _ LOST _ FOCUS : process CaMeL Window CaMeL Focus CaMeL Event ( evt ) ; break ; case Window CaMeL Event . WINDOW _ STATE _ CHANGED : process CaMeL Window CaMeL State CaMeL Event ( evt ) ; break ; } <CTX> protected void process CaMeL Window CaMeL Event ( Window CaMeL Event evt ) { if ( window CaMeL Listener != null ) { switch ( evt . get CaMeL ID ( ) ) { case Window CaMeL Event . WINDOW _ ACTIVATED : window CaMeL Listener . window CaMeL Activated ( evt ) ; break ; case Window CaMeL Event . WINDOW _ CLOSED : window CaMeL Listener . window CaMeL Closed ( evt ) ; break ; case Window CaMeL Event . WINDOW _ CLOSING : window CaMeL Listener . window CaMeL Closing ( evt ) ; break ; case Window CaMeL Event . WINDOW _ DEACTIVATED : window CaMeL Listener . window CaMeL Deactivated ( evt ) ; break ; case Window CaMeL Event . WINDOW _ DEICONIFIED : window CaMeL Listener . window CaMeL Deiconified ( evt ) ; break ; case Window CaMeL Event . WINDOW _ ICONIFIED : window CaMeL Listener . window CaMeL Iconified ( evt ) ; break ; case Window CaMeL Event . WINDOW _ OPENED : window CaMeL Listener . window CaMeL Opened ( evt ) ; break ; case Window CaMeL Event . WINDOW _ GAINED _ FOCUS : case Window CaMeL Event . WINDOW _ LOST _ FOCUS : process CaMeL Window CaMeL Focus CaMeL Event ( evt ) ; break ; case Window CaMeL Event . WINDOW _ STATE _ CHANGED : process CaMeL Window CaMeL State CaMeL Event ( evt ) ; break ; } } }	if ( window CaMeL Listener != null ) { switch ( evt . get CaMeL ID ( ) ) { case Window CaMeL Event . WINDOW _ ACTIVATED : window CaMeL Listener . window CaMeL Activated ( evt ) ; break ; case Window CaMeL Event . WINDOW _ CLOSED : window CaMeL Listener . window CaMeL Closed ( evt ) ; break ; case Window CaMeL Event . WINDOW _ CLOSING : window CaMeL Listener . window CaMeL Closing ( evt ) ; break ; case Window CaMeL Event . WINDOW _ DEACTIVATED : window CaMeL Listener . window CaMeL Deactivated ( evt ) ; break ; case Window CaMeL Event . WINDOW _ DEICONIFIED : window CaMeL Listener . window CaMeL Deiconified ( evt ) ; break ; case Window CaMeL Event . WINDOW _ ICONIFIED : window CaMeL Listener . window CaMeL Iconified ( evt ) ; break ; case Window CaMeL Event . WINDOW _ OPENED : window CaMeL Listener . window CaMeL Opened ( evt ) ; break ; default : break ; } }
get CaMeL Added CaMeL Figure ( ) . display CaMeL Box ( get CaMeL Anchor CaMeL Point ( ) , new Point ( x , y ) ) ; <CTX> public void mouse CaMeL Drag ( Mouse CaMeL Event e , int x , int y ) { if ( get CaMeL Added CaMeL Figure ( ) != null ) { get CaMeL Added CaMeL Figure ( ) . display CaMeL Box ( get CaMeL Anchor CaMeL Point ( ) , new Point ( x , y ) ) ; } }	get CaMeL Added CaMeL Figure ( ) . display CaMeL Box ( new Point ( get CaMeL Anchor CaMeL X ( ) , get CaMeL Anchor CaMeL Y ( ) ) , new Point ( x , y ) ) ;
on CaMeL Internal CaMeL End CaMeL Render ( ) ; <CTX> public final void render ( ) { / / Rendering is beginning on CaMeL Internal CaMeL Begin CaMeL Render ( ) ; on CaMeL Begin CaMeL Render ( ) ; Runtime CaMeL Exception exception = null ; try { / / Get request cycle to render to final Request CaMeL Cycle cycle = get CaMeL Request CaMeL Cycle ( ) ; / / Save original Response final Response original CaMeL Response = cycle . get CaMeL Response ( ) ; / / If component is not visible , set response to Null CaMeL Response if ( ! is CaMeL Visible ( ) ) { cycle . set CaMeL Response ( Null CaMeL Response . get CaMeL Instance ( ) ) ; } / / Synchronize on model lock while rendering to help ensure / / that the model doesn t change while its being read synchronized ( get CaMeL Model CaMeL Lock ( ) ) { / / Call implementation to render component on CaMeL Render ( ) ; / / Tell the page that the component rendered get CaMeL Page ( ) . component CaMeL Rendered ( this ) ; } / / Restore original response cycle . set CaMeL Response ( original CaMeL Response ) ; } catch ( Runtime CaMeL Exception e ) { / / Remember the exception until finally block is / / done and then re - throw it . exception = e ; } finally { try { / / Rendering has completed on CaMeL End CaMeL Render ( ) ; on CaMeL Internal CaMeL End CaMeL Render ( ) ; / / Detach models now that rendering is fully completed detach CaMeL Models ( ) ; } catch ( Runtime CaMeL Exception ex ) { / / Prepare for re - throw only if another exception / / is not yet registered if ( exception == null ) { exception = ex ; } } } / / Ret - throw the exception if ( exception != null ) { throw exception ; } }	internal CaMeL On CaMeL End CaMeL Render ( ) ;
if ( this == sub CaMeL Tree ) return true ; <CTX> public boolean same CaMeL Direction ( boolean is CaMeL Vertical , Layout CaMeL Tree CaMeL Node sub CaMeL Tree ) { boolean tree CaMeL Vertical = get CaMeL Sash ( ) . is CaMeL Vertical ( ) ; if ( tree CaMeL Vertical != is CaMeL Vertical ) return false ; while ( sub CaMeL Tree != null ) { if ( this == sub CaMeL Tree ) return true ; if ( sub CaMeL Tree . children [ 0 ] . is CaMeL Visible ( ) && sub CaMeL Tree . children [ 1 ] . is CaMeL Visible ( ) ) if ( sub CaMeL Tree . get CaMeL Sash ( ) . is CaMeL Vertical ( ) != is CaMeL Vertical ) return false ; sub CaMeL Tree = sub CaMeL Tree . get CaMeL Parent ( ) ; } return true ; }	if ( this == sub CaMeL Tree ) { return true ; }
return new Psi CaMeL Builder CaMeL Impl ( lang , project , Shared CaMeL Impl CaMeL Util . find CaMeL Char CaMeL Table CaMeL By CaMeL Tree ( tree ) , seq ) ; <CTX> public Psi CaMeL Builder create CaMeL Builder ( AST CaMeL Node tree , Language lang , Char CaMeL Sequence seq , final Project project ) { return new Psi CaMeL Builder CaMeL Impl ( lang , project , Shared CaMeL Impl CaMeL Util . find CaMeL Char CaMeL Table CaMeL By CaMeL Tree ( tree ) , seq ) ; }	return new Psi CaMeL Builder CaMeL Impl ( lang , tree , project , seq ) ;
add CaMeL Method ( name , new Callback CaMeL Method ( method ) , Constants . NOEX _ PRIVATE | Constants . NOEX _ CFUNC ) ; <CTX> public void define CaMeL Private CaMeL Method ( String name , Callback method ) { add CaMeL Method ( name , new Callback CaMeL Method ( method ) , Constants . NOEX _ PRIVATE | Constants . NOEX _ CFUNC ) ; }	add CaMeL Method ( name , new Callback CaMeL Method ( method , Visibility . PRIVATE ) ) ;
Class CaMeL Context ( Class CaMeL Type type ) throws Semantic CaMeL Exception { <CTX> Class CaMeL Context ( Class CaMeL Type type ) throws Semantic CaMeL Exception { this . type = type ; this . ts = type . get CaMeL Type CaMeL System ( ) ; }	Class CaMeL Context ( Class CaMeL Type type ) {
I CaMeL Patch my CaMeL Patch = my CaMeL Model . get CaMeL Patch CaMeL At ( table . get CaMeL Selected CaMeL Row ( ) ) ; new Sysex CaMeL Store CaMeL Dialog ( my CaMeL Patch ) ; <CTX> public void store CaMeL Selected CaMeL Patch ( ) { I CaMeL Patch my CaMeL Patch = my CaMeL Model . get CaMeL Patch CaMeL At ( table . get CaMeL Selected CaMeL Row ( ) ) ; new Sysex CaMeL Store CaMeL Dialog ( my CaMeL Patch ) ; }	new Sysex CaMeL Store CaMeL Dialog ( get CaMeL Selected CaMeL Patch ( ) , 0 ) ;
get CaMeL Message CaMeL Text CaMeL Area ( ) . append ( line CaMeL Separator + line CaMeL Separator + exception . get CaMeL Message ( ) ) ; get CaMeL Message CaMeL Frame ( ) . show ( ) ; <CTX> private void handle CaMeL Exception ( Throwable exception ) { / / Write exceptions to the log - window get CaMeL Message CaMeL Text CaMeL Area ( ) . append ( line CaMeL Separator + line CaMeL Separator + exception . get CaMeL Message ( ) ) ; get CaMeL Message CaMeL Frame ( ) . show ( ) ; }	String CaMeL Writer sw = new String CaMeL Writer ( ) ; exception . print CaMeL Stack CaMeL Trace ( new Print CaMeL Writer ( sw ) ) ; String trace = new String ( sw . get CaMeL Buffer ( ) ) ; get CaMeL Message CaMeL Text CaMeL Area ( ) . append ( line CaMeL Separator + line CaMeL Separator + trace ) ; get CaMeL Message CaMeL Frame ( ) . show ( ) ;
return get CaMeL Component CaMeL At ( x , y ) ; <CTX> public Component locate ( int x , int y ) { return get CaMeL Component CaMeL At ( x , y ) ; }	return contains ( x , y ) ? this : null ;
enabled = en ; set CaMeL Changed ( ) ; <CTX> public void set CaMeL Enabled ( boolean en ) { enabled = en ; set CaMeL Changed ( ) ; }	set CaMeL Enabled ( true ) ;
super ( Value CaMeL Type . INTEGER _ TYPE , <CTX> private Integer CaMeL Greater CaMeL Evaluator ( ) { super ( Value CaMeL Type . INTEGER _ TYPE , Operator . GREATER ) ; }	super ( Value CaMeL Type . PINTEGER _ TYPE ,
Text CaMeL Fragment CaMeL Box box = null ; int i ; for ( i = fragments . size ( ) - 1 ; i >= 0 ; i -- ) { box = ( Text CaMeL Fragment CaMeL Box ) fragments . get ( i ) ; if ( box . get CaMeL Baseline ( ) < p . y ) break ; box = null ; <CTX> private int find CaMeL Previous CaMeL Line CaMeL Offset ( Point p ) { if ( get CaMeL Bounds ( ) . y > p . y ) return - 1 ; Text CaMeL Fragment CaMeL Box box = null ; int i ; for ( i = fragments . size ( ) - 1 ; i >= 0 ; i -- ) { box = ( Text CaMeL Fragment CaMeL Box ) fragments . get ( i ) ; if ( box . get CaMeL Baseline ( ) < p . y ) break ; box = null ; } if ( box == null ) return - 1 ; Text CaMeL Layout layout = Flow CaMeL Utilities . get CaMeL Text CaMeL Layout ( ) ; layout . set CaMeL Font ( get CaMeL Font ( ) ) ; String frag CaMeL String ; if ( bidi CaMeL Info == null ) frag CaMeL String = text . substring ( box . offset , box . offset + box . length ) ; else frag CaMeL String = get CaMeL Bidi CaMeL Substring ( box , i ) ; layout . set CaMeL Text ( frag CaMeL String ) ; int trailing [ ] = new int [ 1 ] ; int x = p . x - box . get CaMeL X ( ) ; if ( is CaMeL Mirrored ( ) ) x = box . get CaMeL Width ( ) - x ; int layout CaMeL Offset = layout . get CaMeL Offset ( x , p . y - box . get CaMeL Text CaMeL Top ( ) , trailing ) + trailing [ 0 ] ; layout CaMeL Offset -= get CaMeL Bidi CaMeL Prefix CaMeL Length ( box , i ) ; return box . offset + layout CaMeL Offset ; }	Text CaMeL Fragment CaMeL Box closest CaMeL Box = null ; int index = 0 ; for ( int i = fragments . size ( ) - 1 ; i >= 0 ; i -- ) { Text CaMeL Fragment CaMeL Box box = ( Text CaMeL Fragment CaMeL Box ) fragments . get ( i ) ; if ( box . get CaMeL Baseline ( ) + box . get CaMeL Line CaMeL Root ( ) . content CaMeL Descent < p . y && ( closest CaMeL Box == null || box . get CaMeL Baseline ( ) > closest CaMeL Box . get CaMeL Baseline ( ) || h CaMeL Distance CaMeL Between ( box , p . x ) < h CaMeL Distance CaMeL Between ( closest CaMeL Box , p . x ) ) ) { closest CaMeL Box = box ; index = i ; }
if ( text CaMeL Control == null ) return ; <CTX> public void remove CaMeL Text ( Text text CaMeL Control ) { if ( text CaMeL Control == null ) return ; text CaMeL Control . remove CaMeL Listener ( SWT . Activate , text CaMeL Control CaMeL Listener ) ; text CaMeL Control . remove CaMeL Listener ( SWT . Deactivate , text CaMeL Control CaMeL Listener ) ; text CaMeL Control . remove CaMeL Mouse CaMeL Listener ( mouse CaMeL Adapter ) ; text CaMeL Control . remove CaMeL Key CaMeL Listener ( key CaMeL Adapter ) ; active CaMeL Text CaMeL Control = null ; update CaMeL Actions CaMeL Enable CaMeL State ( ) ; }	if ( text CaMeL Control == null ) { return ; }
Asserts . is CaMeL True ( is CaMeL Current ( ) ) ; <CTX> public void notify CaMeL Started ( ) { Asserts . is CaMeL True ( is CaMeL Current ( ) ) ; synchronized ( has CaMeL Started CaMeL Lock ) { has CaMeL Started = true ; has CaMeL Started CaMeL Lock . notify CaMeL All ( ) ; } }	assert is CaMeL Current ( ) ;
I CaMeL Style row CaMeL Style = ( last CaMeL Row == null ? null : last CaMeL Row CaMeL Area . get CaMeL Content ( ) . get CaMeL Computed CaMeL Style ( ) ) ; <CTX> protected void close CaMeL Table CaMeL Layout ( ) { close CaMeL Layout ( new I CaMeL Bottom CaMeL Border CaMeL Resolver CaMeL Strategy ( ) { public int resolve CaMeL Bottom CaMeL Border ( Cell CaMeL Area cell ) { I CaMeL Style table CaMeL Style = table CaMeL Content . get CaMeL Computed CaMeL Style ( ) ; I CaMeL Style row CaMeL Style = ( last CaMeL Row == null ? null : last CaMeL Row CaMeL Area . get CaMeL Content ( ) . get CaMeL Computed CaMeL Style ( ) ) ; I CaMeL Style column CaMeL Style = get CaMeL Column CaMeL Style ( cell . get CaMeL Column CaMeL ID ( ) ) ; I CaMeL Style cell CaMeL Content CaMeL Style = cell . get CaMeL Content ( ) . get CaMeL Computed CaMeL Style ( ) ; I CaMeL Style cell CaMeL Area CaMeL Style = cell . get CaMeL Style ( ) ; bcr . resolve CaMeL Table CaMeL Bottom CaMeL Border ( table CaMeL Style , row CaMeL Style , column CaMeL Style , cell CaMeL Content CaMeL Style , cell CaMeL Area CaMeL Style ) ; return get CaMeL Dimension CaMeL Value ( cell CaMeL Area CaMeL Style . get CaMeL Property ( Style CaMeL Constants . STYLE _ BORDER _ BOTTOM _ WIDTH ) ) ; } } ) ; }	I CaMeL Content cell CaMeL Content = cell . get CaMeL Content ( ) ; I CaMeL Style row CaMeL Style = ( ( I CaMeL Content ) cell CaMeL Content . get CaMeL Parent ( ) ) . get CaMeL Computed CaMeL Style ( ) ;
return Ruby CaMeL Boolean . new CaMeL Boolean ( runtime , obj . is CaMeL Kind CaMeL Of ( this ) ) ; <CTX> public Ruby CaMeL Boolean op _ eqq ( I CaMeL Ruby CaMeL Object obj ) { return Ruby CaMeL Boolean . new CaMeL Boolean ( runtime , obj . is CaMeL Kind CaMeL Of ( this ) ) ; }	return get CaMeL Runtime ( ) . new CaMeL Boolean ( obj . is CaMeL Kind CaMeL Of ( this ) ) ;
Viewed CaMeL Message msg = ( Viewed CaMeL Message ) path . get CaMeL Tip ( ) ; <CTX> synchronized Vector get CaMeL Selected CaMeL Viewed CaMeL Message CaMeL Vector ( ) { Vector msg CaMeL Vector = new Vector ( ) ; Selection CaMeL Manager selection = f CaMeL Message CaMeL Tree . get CaMeL Selection CaMeL Manager ( ) ; Enumeration messages = selection . get CaMeL Selection ( ) ; while ( messages . has CaMeL More CaMeL Elements ( ) ) { Tree CaMeL Path path = ( Tree CaMeL Path ) messages . next CaMeL Element ( ) ; Viewed CaMeL Message msg = ( Viewed CaMeL Message ) path . get CaMeL Tip ( ) ; if ( msg != null ) { msg CaMeL Vector . insert CaMeL Element CaMeL At ( msg , msg CaMeL Vector . size ( ) ) ; } } return msg CaMeL Vector ; }	Viewed CaMeL Message msg = ( Viewed CaMeL Message ) path . get CaMeL Path ( ) [ path . get CaMeL Path ( ) . length - 1 ] ;
Db CaMeL Mailbox . update CaMeL Highest CaMeL Item ( this ) ; <CTX> private int get CaMeL Next CaMeL Item CaMeL Id ( int id CaMeL From CaMeL Redo ) throws Service CaMeL Exception { int last CaMeL Id = get CaMeL Last CaMeL Item CaMeL Id ( ) ; int next CaMeL Id = ( id CaMeL From CaMeL Redo == ID _ AUTO _ INCREMENT ? last CaMeL Id + 1 : id CaMeL From CaMeL Redo ) ; if ( next CaMeL Id > last CaMeL Id ) { m CaMeL Current CaMeL Change . item CaMeL Id = next CaMeL Id ; if ( next CaMeL Id / Db CaMeL Mailbox . ITEM _ CHECKPOINT _ INCREMENT > last CaMeL Id / Db CaMeL Mailbox . ITEM _ CHECKPOINT _ INCREMENT ) Db CaMeL Mailbox . update CaMeL Highest CaMeL Item ( this ) ; } return next CaMeL Id ; }	Db CaMeL Mailbox . update CaMeL Mailbox CaMeL Stats ( this ) ;
excptn CaMeL Class != Exception . class ) { <CTX> public void handle CaMeL Native CaMeL Exception ( Exception exception ) { if ( exception instanceof Raise CaMeL Exception ) { throw ( Raise CaMeL Exception ) exception ; } Class excptn CaMeL Class = exception . get CaMeL Class ( ) ; Ruby CaMeL Proc handler = ( Ruby CaMeL Proc ) exception CaMeL Handlers . get ( excptn CaMeL Class . get CaMeL Name ( ) ) ; while ( handler == null && excptn CaMeL Class != Exception . class ) { excptn CaMeL Class = excptn CaMeL Class . get CaMeL Superclass ( ) ; } if ( handler != null ) { handler . call ( new I CaMeL Ruby CaMeL Object [ ] { Java CaMeL Util . convert CaMeL Java CaMeL To CaMeL Ruby ( runtime , exception ) } ) ; } else { throw create CaMeL Raise CaMeL Exception ( exception ) ; } }	excptn CaMeL Class != Throwable . class ) {
return maven CaMeL Project CaMeL Builder . build CaMeL With CaMeL Dependencies ( maven CaMeL Project , local CaMeL Repository , profile CaMeL Manager ) ; <CTX> public Maven CaMeL Project read CaMeL Project CaMeL With CaMeL Dependencies ( File maven CaMeL Project ) throws Project CaMeL Building CaMeL Exception , Artifact CaMeL Resolution CaMeL Exception { return maven CaMeL Project CaMeL Builder . build CaMeL With CaMeL Dependencies ( maven CaMeL Project , local CaMeL Repository , profile CaMeL Manager ) ; }	return maven CaMeL Project CaMeL Builder . build CaMeL With CaMeL Dependencies ( maven CaMeL Project , local CaMeL Repository , profile CaMeL Manager , transfer CaMeL Listener ) ;
this . property CaMeL On CaMeL Delete = property CaMeL On CaMeL Delete ; <CTX> public void set CaMeL Property CaMeL On CaMeL Delete ( String property CaMeL On CaMeL Delete ) { this . property CaMeL On CaMeL Delete = property CaMeL On CaMeL Delete ; }	properties . assign CaMeL Property CaMeL On CaMeL Delete CaMeL Name ( property CaMeL On CaMeL Delete ) ;
if ( super CaMeL Class != null ) { return super CaMeL Class . get CaMeL Custom CaMeL Build CaMeL Step ( ) ; <CTX> public boolean get CaMeL Custom CaMeL Build CaMeL Step ( ) { if ( custom CaMeL Build CaMeL Step == null ) { if ( super CaMeL Class != null ) { return super CaMeL Class . get CaMeL Custom CaMeL Build CaMeL Step ( ) ; } else { return false ; / / default is false } } return custom CaMeL Build CaMeL Step . boolean CaMeL Value ( ) ; }	if ( get CaMeL Super CaMeL Class ( ) != null ) { return get CaMeL Super CaMeL Class ( ) . get CaMeL Custom CaMeL Build CaMeL Step ( ) ;
( ( I CaMeL Privileged ) channel ) . set CaMeL Portal CaMeL Control CaMeL Structures ( pcs ) ; <CTX> public void set CaMeL Portal CaMeL Control CaMeL Structures ( Portal CaMeL Control CaMeL Structures pcs ) throws Portal CaMeL Exception { ( ( I CaMeL Privileged ) channel ) . set CaMeL Portal CaMeL Control CaMeL Structures ( pcs ) ; }	( ( I CaMeL Multithreaded CaMeL Privileged ) channel ) . set CaMeL Portal CaMeL Control CaMeL Structures ( pcs , uid ) ;
Component get CaMeL Component ( I CaMeL Settings settings ) ; <CTX> Component get CaMeL Component ( I CaMeL Settings settings ) ;	Component get CaMeL Component ( I CaMeL Settings settings , Data CaMeL Engine data CaMeL Engine ) ;
return this . encode CaMeL Redirect CaMeL Url ( url ) ; <CTX> public String encode CaMeL Redirect CaMeL Url ( String url ) { return this . encode CaMeL Redirect CaMeL Url ( url ) ; }	return this . delegate . encode CaMeL Redirect CaMeL Url ( url ) ;
URL url = Platform . find ( bundle , new Path ( editor CaMeL Info . get CaMeL Icon CaMeL Path ( ) ) ) ; <CTX> public Image CaMeL Descriptor get CaMeL Image CaMeL Descriptor ( String editor CaMeL Kind ) { Cheat CaMeL Sheet CaMeL Registry CaMeL Reader . Task CaMeL Editor CaMeL Node editor CaMeL Info = Cheat CaMeL Sheet CaMeL Registry CaMeL Reader . get CaMeL Instance ( ) . find CaMeL Task CaMeL Editor ( editor CaMeL Kind ) ; if ( editor CaMeL Info != null ) { Bundle bundle = Platform . get CaMeL Bundle ( editor CaMeL Info . get CaMeL Plugin CaMeL Id ( ) ) ; URL url = Platform . find ( bundle , new Path ( editor CaMeL Info . get CaMeL Icon CaMeL Path ( ) ) ) ; if ( url != null ) { try { url = Platform . resolve ( url ) ; return Image CaMeL Descriptor . create CaMeL From CaMeL URL ( url ) ; } catch ( IO CaMeL Exception e ) { return null ; } } } return null ; }	URL url = File CaMeL Locator . find ( bundle , new Path ( editor CaMeL Info . get CaMeL Icon CaMeL Path ( ) ) , null ) ;
return Ruby CaMeL String . new CaMeL String ( runtime , new Printf CaMeL Format ( Locale . US , get CaMeL Value ( ) ) . sprintf ( args ) ) ; <CTX> public I CaMeL Ruby CaMeL Object format ( I CaMeL Ruby CaMeL Object arg ) { if ( arg instanceof Ruby CaMeL Array ) { Object [ ] args = new Object [ ( ( Ruby CaMeL Array ) arg ) . get CaMeL Length ( ) ] ; for ( int i = 0 ; i < args . length ; i ++ ) { args [ i ] = Java CaMeL Util . convert CaMeL Ruby CaMeL To CaMeL Java ( ( ( Ruby CaMeL Array ) arg ) . entry ( i ) ) ; } return Ruby CaMeL String . new CaMeL String ( runtime , new Printf CaMeL Format ( Locale . US , get CaMeL Value ( ) ) . sprintf ( args ) ) ; } return Ruby CaMeL String . new CaMeL String ( runtime , new Printf CaMeL Format ( Locale . US , get CaMeL Value ( ) ) . sprintf ( Java CaMeL Util . convert CaMeL Ruby CaMeL To CaMeL Java ( arg ) ) ) ; }	return get CaMeL Runtime ( ) . new CaMeL String ( new Printf CaMeL Format ( Locale . US , get CaMeL Value ( ) ) . sprintf ( args ) ) ;
if ( gap CaMeL Offset < offset ) root . content CaMeL Inserted ( gap CaMeL Offset , offset , gap CaMeL Width ) ; <CTX> public synchronized void content CaMeL Inserted ( int offset , int length ) { if ( root == null ) { gap CaMeL Width = 0 ; return ; } int new CaMeL Gap CaMeL Offset ; Pos CaMeL Bottom CaMeL Half highest = root . find CaMeL Highest ( offset ) ; if ( highest == null ) new CaMeL Gap CaMeL Offset = 0 ; else new CaMeL Gap CaMeL Offset = highest . get CaMeL Offset ( ) + 1 ; if ( gap CaMeL Width != 0 ) { if ( gap CaMeL Offset < offset ) root . content CaMeL Inserted ( gap CaMeL Offset , offset , gap CaMeL Width ) ; else root . content CaMeL Inserted ( offset , gap CaMeL Offset , - gap CaMeL Width ) ; } gap CaMeL Offset = new CaMeL Gap CaMeL Offset ; gap CaMeL Width += length ; } / / } } }	if ( gap CaMeL Starts CaMeL At . offset < offset ) root . content CaMeL Inserted ( gap CaMeL Starts CaMeL At . offset , offset , gap CaMeL Width ) ;
while ( iterator . has CaMeL Next ( ) ) Util . assert CaMeL Instance ( iterator . next ( ) , Activity CaMeL Definition . class ) ; <CTX> static void write CaMeL Activity CaMeL Definitions ( I CaMeL Memento memento , String name , List activity CaMeL Definitions ) { if ( memento == null || name == null || activity CaMeL Definitions == null ) throw new Null CaMeL Pointer CaMeL Exception ( ) ; activity CaMeL Definitions = new Array CaMeL List ( activity CaMeL Definitions ) ; Iterator iterator = activity CaMeL Definitions . iterator ( ) ; while ( iterator . has CaMeL Next ( ) ) Util . assert CaMeL Instance ( iterator . next ( ) , Activity CaMeL Definition . class ) ; iterator = activity CaMeL Definitions . iterator ( ) ; while ( iterator . has CaMeL Next ( ) ) write CaMeL Activity CaMeL Definition ( memento . create CaMeL Child ( name ) , ( Activity CaMeL Definition ) iterator . next ( ) ) ; }	while ( iterator . has CaMeL Next ( ) ) { Util . assert CaMeL Instance ( iterator . next ( ) , Activity CaMeL Definition . class ) ; }
boolean doors , boolean hotspots ) { <CTX> public static void load CaMeL Data ( Hack CaMeL Module hm , boolean sprites , boolean doors , boolean hotspots ) { load CaMeL Map CaMeL Addresses ( hm . rom ) ; load CaMeL Draw CaMeL Tilesets ( hm . rom ) ; if ( sprites ) { TPT CaMeL Editor . read CaMeL From CaMeL Rom ( hm ) ; Sprite CaMeL Editor . read CaMeL From CaMeL Rom ( hm . rom ) ; load CaMeL Sprite CaMeL Data ( hm . rom ) ; } if ( doors ) load CaMeL Door CaMeL Data ( hm . rom ) ; if ( hotspots ) Hotspot CaMeL Editor . read CaMeL From CaMeL Rom ( hm ) ; }	boolean doors , boolean hotspots , boolean enemies , boolean map CaMeL Changes ) {
Iterator < String > i = bug CaMeL Code CaMeL List . iterator ( ) ; while ( i . has CaMeL Next ( ) ) { if ( bug CaMeL Code . equals ( i . next ( ) ) ) <CTX> public boolean match ( Bug CaMeL Instance bug CaMeL Instance ) { String bug CaMeL Code = bug CaMeL Instance . get CaMeL Abbrev ( ) ; Iterator < String > i = bug CaMeL Code CaMeL List . iterator ( ) ; while ( i . has CaMeL Next ( ) ) { if ( bug CaMeL Code . equals ( i . next ( ) ) ) return true ; } return false ; }	for ( String a CaMeL Bug CaMeL Code CaMeL List : bug CaMeL Code CaMeL List ) { if ( bug CaMeL Code . equals ( a CaMeL Bug CaMeL Code CaMeL List ) )
return r . bounds ; <CTX> public Rectangle get CaMeL Bounds ( Tree CaMeL Path path , Rectangle rect ) { if ( dirty ) update ( ) ; Object last = path . get CaMeL Last CaMeL Path CaMeL Component ( ) ; Node CaMeL Record r = ( Node CaMeL Record ) nodes . get ( last ) ; if ( r == null ) / / This node is not visible . return new Rectangle ( ) ; else { if ( r . bounds == null ) { Rectangle dim = get CaMeL Node CaMeL Dimensions ( last , r . row , r . depth , r . is CaMeL Expanded , rect ) ; r . bounds = dim ; } return r . bounds ; } }	rect . set CaMeL Rect ( r . bounds ) ;
return new Cross CaMeL Join CaMeL Fun CaMeL Def ( dummy CaMeL Fun CaMeL Def ) ; <CTX> protected Fun CaMeL Def create CaMeL Fun CaMeL Def ( Exp [ ] args , Fun CaMeL Def dummy CaMeL Fun CaMeL Def ) { return new Cross CaMeL Join CaMeL Fun CaMeL Def ( dummy CaMeL Fun CaMeL Def ) ; }	return new Fun CaMeL Def CaMeL Base ( dummy CaMeL Fun CaMeL Def ) { public Object evaluate ( Evaluator evaluator , Exp [ ] args ) { Hash CaMeL Set set = new Hash CaMeL Set ( ) ; set . add CaMeL All ( ( List ) get CaMeL Arg ( evaluator , args , 1 ) ) ; List set 1 = ( List ) get CaMeL Arg ( evaluator , args , 0 ) ; List result = new Array CaMeL List ( ) ; for ( int i = 0 , count = set 1 . size ( ) ; i < count ; i ++ ) { Object o = set 1 . get ( i ) ; if ( ! set . contains ( o ) ) { result . add ( o ) ; } } return result ; } } ;
return model . find CaMeL Parameter ( param CaMeL Name ) ; <CTX> public Parameter CaMeL Handle find CaMeL Parameter ( String param CaMeL Name ) throws Report CaMeL Service CaMeL Exception { if ( param CaMeL Name == null ) return null ; I CaMeL Report CaMeL Runnable runnable = ( I CaMeL Report CaMeL Runnable ) this . report CaMeL Design CaMeL Handle . get CaMeL Design CaMeL Object ( ) ; assert runnable != null ; Module CaMeL Handle model = runnable . get CaMeL Design CaMeL Handle ( ) . get CaMeL Module CaMeL Handle ( ) ; assert model != null ; return model . find CaMeL Parameter ( param CaMeL Name ) ; }	if ( runnable != null ) model = runnable . get CaMeL Design CaMeL Handle ( ) . get CaMeL Module CaMeL Handle ( ) ; if ( model != null ) return model . find CaMeL Parameter ( param CaMeL Name ) ; else return null ;
return value CaMeL Map . key CaMeL Set ( ) . iterator ( ) ; <CTX> private Iterator key CaMeL Iterator ( ) { return value CaMeL Map . key CaMeL Set ( ) . iterator ( ) ; }	return new Array CaMeL List ( value CaMeL Map . key CaMeL Set ( ) ) . iterator ( ) ;
void set CaMeL Big CaMeL Decimal ( int parameter CaMeL Index , Big CaMeL Decimal x ) throws <CTX> void set CaMeL Big CaMeL Decimal ( int parameter CaMeL Index , Big CaMeL Decimal x ) throws SQL CaMeL Exception ;	void set CaMeL Big CaMeL Decimal ( int index , Big CaMeL Decimal value ) throws
Array CaMeL List list = handle . get CaMeL List CaMeL Value ( ) ; if ( list != null ) <CTX> private final void clear CaMeL Unused CaMeL Column CaMeL Hints ( Data CaMeL Set CaMeL Handle data CaMeL Set CaMeL Handle , I CaMeL Result CaMeL Meta CaMeL Data meta CaMeL Data ) throws Birt CaMeL Exception { Property CaMeL Handle handle = data CaMeL Set CaMeL Handle . get CaMeL Property CaMeL Handle ( Data CaMeL Set CaMeL Handle . COLUMN _ HINTS _ PROP ) ; Array CaMeL List list = handle . get CaMeL List CaMeL Value ( ) ; if ( list != null ) { int count = list . size ( ) ; for ( int n = count - 1 ; n >= 0 ; n -- ) { Column CaMeL Hint hint = ( Column CaMeL Hint ) list . get ( n ) ; String column CaMeL Name = ( String ) hint . get CaMeL Property ( handle . get CaMeL Design ( ) , Column CaMeL Hint . COLUMN _ NAME _ MEMBER ) ; boolean found = false ; if ( ! is CaMeL Empty ( hint , handle . get CaMeL Module ( ) . get CaMeL Module CaMeL Handle ( ) ) ) { for ( int m = 0 ; m < meta CaMeL Data . get CaMeL Column CaMeL Count ( ) && ! found ; m ++ ) { found = column CaMeL Name . equals ( meta CaMeL Data . get CaMeL Column CaMeL Name ( m + 1 ) ) ; } } if ( ! found ) { try { / / remove the item handle . remove CaMeL Item ( hint ) ; } catch ( Property CaMeL Value CaMeL Exception e ) { } } } } }	if ( handle != null && handle . get CaMeL List CaMeL Value ( ) != null )
set CaMeL Street ( STREET _ DEFAULT ) ; <CTX> public void reset CaMeL Property CaMeL Value ( Object property ) { if ( P _ ID _ POSTALCODE . equals ( property ) ) { set CaMeL Postal CaMeL Code ( POSTALCODE _ DEFAULT ) ; return ; } if ( P _ ID _ CITY . equals ( property ) ) { set CaMeL City ( CITY _ DEFAULT ) ; return ; } if ( P _ ID _ PROVINCE . equals ( property ) ) { set CaMeL Province ( PROVINCE _ DEFAULT ) ; return ; } ; if ( P _ ID _ STREET . equals ( property ) ) { set CaMeL Street ( STREET _ DEFAULT ) ; return ; } }	set CaMeL Street ( new Street CaMeL Address ( ) ) ;
return new Font CaMeL Render CaMeL Context ( null , true , true ) ; <CTX> public Font CaMeL Render CaMeL Context get CaMeL Font CaMeL Render CaMeL Context ( ) { return new Font CaMeL Render CaMeL Context ( null , true , true ) ; }	boolean antialias = Rendering CaMeL Hints . VALUE _ TEXT _ ANTIALIAS _ ON . equals ( get CaMeL Rendering CaMeL Hint ( Rendering CaMeL Hints . KEY _ TEXT _ ANTIALIASING ) ) ; boolean fractions = Rendering CaMeL Hints . VALUE _ FRACTIONALMETRICS _ ON . equals ( get CaMeL Rendering CaMeL Hint ( Rendering CaMeL Hints . KEY _ FRACTIONALMETRICS ) ) ; return new Font CaMeL Render CaMeL Context ( new Affine CaMeL Transform ( ) , antialias , fractions ) ;
save CaMeL Project CaMeL As CaMeL Item CaMeL Action CaMeL Performed ( evt ) ; <CTX> public void action CaMeL Performed ( java . awt . event . Action CaMeL Event evt ) { save CaMeL Project CaMeL As CaMeL Item CaMeL Action CaMeL Performed ( evt ) ; }	load CaMeL Bugs CaMeL Item CaMeL Action CaMeL Performed ( evt ) ;
view . set CaMeL Sorter ( dialog . get CaMeL Sorter ( ) ) ; <CTX> public void run ( ) { if ( dialog . open ( ) == Window . OK && dialog . is CaMeL Dirty ( ) ) { view . set CaMeL Sorter ( dialog . get CaMeL Sorter ( ) ) ; } }	view . set CaMeL Comparator ( dialog . get CaMeL Sorter ( ) ) ;
this . call CaMeL Listeners . remove ( listener ) ; <CTX> public void remove CaMeL Call CaMeL Change CaMeL Listener ( Call CaMeL Change CaMeL Listener listener ) { this . call CaMeL Listeners . remove ( listener ) ; }	synchronized ( call CaMeL Listeners ) { this . call CaMeL Listeners . remove ( listener ) ; }
comp . method . compile _ push _ string ( symbol . to CaMeL String ( ) ) ; <CTX> public void compile ( Compilation comp , boolean ignore _ result ) { if ( ignore _ result ) return ; if ( binding != null ) compile _ load ( binding , comp ) ; else { comp . method . compile _ push _ string ( symbol . to CaMeL String ( ) ) ; comp . method . compile _ invoke _ static ( comp . lookup CaMeL Global CaMeL Method ) ; } }	comp . compile CaMeL Constant ( symbol ) ; if ( comp . immediate ) comp . method . compile _ checkcast ( comp . scm CaMeL Symbol CaMeL Type ) ;
Asserts . is CaMeL True ( arity >= 0 ) ; <CTX> public static Arity fixed ( int arity ) { Asserts . is CaMeL True ( arity >= 0 ) ; return create CaMeL Arity ( arity ) ; }	assert arity >= 0 ;
return new Line CaMeL Series CaMeL Attribute CaMeL Composite ( parent , SWT . NONE , series ) ; <CTX> public Composite get CaMeL Series CaMeL Attribute CaMeL Sheet ( Composite parent , Series series , IUI CaMeL Service CaMeL Provider builder , Object o CaMeL Context ) { return new Line CaMeL Series CaMeL Attribute CaMeL Composite ( parent , SWT . NONE , series ) ; }	return new Line CaMeL Series CaMeL Attribute CaMeL Composite ( parent , SWT . NONE , context , series ) ;
Output CaMeL Stream CaMeL Writer osw = new Output CaMeL Stream CaMeL Writer ( output CaMeL Stream , get CaMeL Character CaMeL Set ( ) . get CaMeL Name ( ) ) ; <CTX> public void write ( Output CaMeL Stream output CaMeL Stream ) throws IO CaMeL Exception { if ( get CaMeL Value ( ) != null ) { Output CaMeL Stream CaMeL Writer osw = new Output CaMeL Stream CaMeL Writer ( output CaMeL Stream , get CaMeL Character CaMeL Set ( ) . get CaMeL Name ( ) ) ; osw . write ( get CaMeL Value ( ) ) ; } }	Output CaMeL Stream CaMeL Writer osw = null ; if ( get CaMeL Character CaMeL Set ( ) != null ) { osw = new Output CaMeL Stream CaMeL Writer ( output CaMeL Stream , get CaMeL Character CaMeL Set ( ) . get CaMeL Name ( ) ) ; } else { osw = new Output CaMeL Stream CaMeL Writer ( output CaMeL Stream ) ; }
&& _ group != null && ! _ socket . is CaMeL Closed ( ) ) { _ socket . leave CaMeL Group ( _ group ) ; <CTX> void set CaMeL Listening CaMeL Socket ( Multicast CaMeL Socket multicast CaMeL Socket ) throws IO CaMeL Exception { / / a ) Close old socket ( if non - null ) to alert lock holders . . . if ( _ socket != null ) _ socket . close ( ) ; / / b ) Replace with new sock . Notify the udp CaMeL Thread . synchronized ( _ receive CaMeL Lock ) { / / synchronized ( _ send CaMeL Lock ) { / / if the input is null , then the service will shut off ; ) . / / leave the group if we re shutting off the service . if ( multicast CaMeL Socket == null && _ socket != null && _ group != null && ! _ socket . is CaMeL Closed ( ) ) { _ socket . leave CaMeL Group ( _ group ) ; } _ socket = ( Multicast CaMeL Socket ) multicast CaMeL Socket ; _ receive CaMeL Lock . notify ( ) ; / / _ send CaMeL Lock . notify ( ) ; / / } } }	&& _ group != null ) { try { _ socket . leave CaMeL Group ( _ group ) ; } catch ( IO CaMeL Exception ignored ) { }
return convert CaMeL To CaMeL Class ( ( ( Parameterized CaMeL Type ) type ) . get CaMeL Actual CaMeL Type CaMeL Arguments ( ) [ 0 ] ) ; <CTX> public Class get CaMeL Scalar CaMeL Type ( ) { if ( this . type CaMeL Information CaMeL Valid ) { Type type = this . leaf . get CaMeL Value CaMeL Type ( ) ; Class clazz = convert CaMeL To CaMeL Class ( type ) ; if ( clazz . is CaMeL Array ( ) ) { return clazz . get CaMeL Component CaMeL Type ( ) ; } else if ( Collection . class . is CaMeL Assignable CaMeL From ( clazz ) ) { if ( type instanceof Parameterized CaMeL Type ) { return convert CaMeL To CaMeL Class ( ( ( Parameterized CaMeL Type ) type ) . get CaMeL Actual CaMeL Type CaMeL Arguments ( ) [ 0 ] ) ; } else { return String . class ; } } else if ( Map . class . is CaMeL Assignable CaMeL From ( clazz ) ) { if ( type instanceof Parameterized CaMeL Type ) { return convert CaMeL To CaMeL Class ( ( ( Parameterized CaMeL Type ) type ) . get CaMeL Actual CaMeL Type CaMeL Arguments ( ) [ 1 ] ) ; } else { return String . class ; } } else { return clazz ; } } else { return null ; } }	return convert CaMeL To CaMeL Class ( ( ( Parameterized CaMeL Type ) type ) . get CaMeL Actual CaMeL Type CaMeL Arguments ( ) [ 0 ] , this . leaf ) ;
target [ 0 ] = new C CaMeL Debug CaMeL Target ( launch , IC CaMeL Debug CaMeL Target CaMeL Type . TARGET _ TYPE _ LOCAL _ RUN , <CTX> public void run ( I CaMeL Progress CaMeL Monitor m ) { target [ 0 ] = new C CaMeL Debug CaMeL Target ( launch , IC CaMeL Debug CaMeL Target CaMeL Type . TARGET _ TYPE _ LOCAL _ RUN , cdi CaMeL Target , name , debuggee CaMeL Process , debugger CaMeL Process , file , allow CaMeL Terminate , allow CaMeL Disconnect ) ; }	target [ 0 ] = new C CaMeL Debug CaMeL Target ( launch , IC CaMeL Debug CaMeL Target CaMeL Type . TARGET _ TYPE _ LOCAL _ ATTACH ,
if ( new CaMeL Work . get CaMeL Peek ( ) == null && new CaMeL Work . get CaMeL Pop ( ) == null && new CaMeL Work . get CaMeL Push ( ) == null ) { <CTX> public void set CaMeL Init CaMeL Work ( J CaMeL Method CaMeL Declaration new CaMeL Work ) { / / if new work function has no I / O rates and old one does , / / then transfer rates to new one . This is an ugly remnant of / / the old mode of operation , where I / O rates were stored / / outside the function . if ( new CaMeL Work . get CaMeL Peek ( ) == null && new CaMeL Work . get CaMeL Pop ( ) == null && new CaMeL Work . get CaMeL Push ( ) == null ) { new CaMeL Work . set CaMeL Peek ( get CaMeL Init CaMeL Work ( ) . get CaMeL Peek ( ) ) ; new CaMeL Work . set CaMeL Pop ( get CaMeL Init CaMeL Work ( ) . get CaMeL Pop ( ) ) ; new CaMeL Work . set CaMeL Push ( get CaMeL Init CaMeL Work ( ) . get CaMeL Push ( ) ) ; } add CaMeL Replacement CaMeL Method ( new CaMeL Work , get CaMeL Init CaMeL Work ( ) ) ; get CaMeL Init CaMeL Phases ( ) [ 0 ] = new CaMeL Work ; check CaMeL Rep ( ) ; }	if ( ! new CaMeL Work . does CaMeL IO ( ) ) {
String o 0 = get CaMeL String CaMeL Arg ( evaluator , args , 0 , null ) ; String o 1 = get CaMeL String CaMeL Arg ( evaluator , args , 1 , null ) ; if ( o 0 == null || o 1 == null ) { <CTX> public Object evaluate ( Evaluator evaluator , Exp [ ] args ) { String o 0 = get CaMeL String CaMeL Arg ( evaluator , args , 0 , null ) ; String o 1 = get CaMeL String CaMeL Arg ( evaluator , args , 1 , null ) ; if ( o 0 == null || o 1 == null ) { return null ; } return Boolean . value CaMeL Of ( o 0 . compare CaMeL To ( o 1 ) > 0 ) ; }	Double o 0 = get CaMeL Double CaMeL Arg ( evaluator , args , 0 ) ; Double o 1 = get CaMeL Double CaMeL Arg ( evaluator , args , 1 ) ; if ( o 0 . is CaMeL Na CaMeL N ( ) || o 1 . is CaMeL Na CaMeL N ( ) ) {
this . project CaMeL File = new File ( project CaMeL File ) ; <CTX> public void set CaMeL Project CaMeL File ( String project CaMeL File ) { this . project CaMeL File = new File ( project CaMeL File ) ; }	this . project CaMeL Attribute = project CaMeL Attribute ;
if ( ! name CaMeL Status . is CaMeL OK ( ) ) <CTX> private String check CaMeL Valid CaMeL Name ( ) { String name = this . project CaMeL Name CaMeL Field . get CaMeL Text ( ) ; I CaMeL Workspace workspace = get CaMeL Project ( ) . get CaMeL Workspace ( ) ; I CaMeL Status name CaMeL Status = workspace . validate CaMeL Name ( name , I CaMeL Resource . PROJECT ) ; if ( ! name CaMeL Status . is CaMeL OK ( ) ) return name CaMeL Status . get CaMeL Message ( ) ; I CaMeL Project new CaMeL Project = workspace . get CaMeL Root ( ) . get CaMeL Project ( name ) ; if ( new CaMeL Project . exists ( ) ) { return NLS . bind ( IDE CaMeL Workbench CaMeL Messages . Copy CaMeL Project CaMeL Action _ already CaMeL Exists , name ) ; } return null ; }	if ( ! name CaMeL Status . is CaMeL OK ( ) ) {
synchronized ( messages ) { for ( Iterator iter = messages . iterator ( ) ; iter . has CaMeL Next ( ) ; ) { try { Message CaMeL Reference r = ( Message CaMeL Reference ) iter . next ( ) ; if ( message CaMeL Id . equals ( r . get CaMeL Message CaMeL Id ( ) . to CaMeL String ( ) ) ) { r . increment CaMeL Reference CaMeL Count ( ) ; try { Message m = r . get CaMeL Message ( ) ; Broker CaMeL Support . resend ( context , m , dest ) ; } finally { r . decrement CaMeL Reference CaMeL Count ( ) ; } return true ; } } catch ( IO CaMeL Exception e ) { } } } return false ; <CTX> public boolean copy CaMeL Message CaMeL To ( Connection CaMeL Context context , String message CaMeL Id , Active CaMeL MQ CaMeL Destination dest ) throws Exception { synchronized ( messages ) { for ( Iterator iter = messages . iterator ( ) ; iter . has CaMeL Next ( ) ; ) { try { Message CaMeL Reference r = ( Message CaMeL Reference ) iter . next ( ) ; if ( message CaMeL Id . equals ( r . get CaMeL Message CaMeL Id ( ) . to CaMeL String ( ) ) ) { r . increment CaMeL Reference CaMeL Count ( ) ; try { Message m = r . get CaMeL Message ( ) ; Broker CaMeL Support . resend ( context , m , dest ) ; } finally { r . decrement CaMeL Reference CaMeL Count ( ) ; } return true ; } } catch ( IO CaMeL Exception e ) { } } } return false ; }	return copy CaMeL Matching CaMeL Messages ( context , create CaMeL Message CaMeL Id CaMeL Filter ( message CaMeL Id ) , dest , 1 ) > 0 ;
if ( objects . size ( ) == 1 ) return common CaMeL Class ; <CTX> private Class get CaMeL Common CaMeL Class ( List objects ) { if ( objects == null || objects . size ( ) == 0 ) return null ; Class common CaMeL Class = objects . get ( 0 ) . get CaMeL Class ( ) ; / / try easy if ( objects . size ( ) == 1 ) return common CaMeL Class ; / / try harder for ( int i = 1 ; i < objects . size ( ) ; i ++ ) { Object object = objects . get ( i ) ; Class new CaMeL Class = object . get CaMeL Class ( ) ; / / try the short cut if ( new CaMeL Class . equals ( common CaMeL Class ) ) continue ; / / compute common class common CaMeL Class = get CaMeL Common CaMeL Class ( common CaMeL Class , new CaMeL Class ) ; / / give up if ( common CaMeL Class == null ) return null ; } return common CaMeL Class ; }	if ( objects . size ( ) == 1 ) { return common CaMeL Class ;
Single CaMeL Variable CaMeL Declaration result = target CaMeL Ast . new CaMeL Single CaMeL Variable CaMeL Declaration ( ) ; <CTX> public AST CaMeL Node sample ( AST target CaMeL Ast , boolean parented ) { Single CaMeL Variable CaMeL Declaration result = target CaMeL Ast . new CaMeL Single CaMeL Variable CaMeL Declaration ( ) ; if ( parented ) { target CaMeL Ast . new CaMeL Catch CaMeL Clause ( ) . set CaMeL Exception ( result ) ; } return result ; }	Block result = target CaMeL Ast . new CaMeL Block ( ) ;
assert prop CaMeL Defn . is CaMeL List ( ) ; <CTX> private static Object validate CaMeL List ( Design CaMeL Element CaMeL Handle element , Element CaMeL Property CaMeL Defn prop CaMeL Defn , Object value ) throws Semantic CaMeL Exception { if ( ! ( value instanceof List ) ) return null ; assert prop CaMeL Defn . is CaMeL List ( ) ; List ret CaMeL List = new Array CaMeL List ( ) ; List list = ( List ) value ; I CaMeL Structure CaMeL Defn struct CaMeL Defn = prop CaMeL Defn . get CaMeL Struct CaMeL Defn ( ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { I CaMeL Structure item = ( I CaMeL Structure ) list . get ( i ) ; if ( item . get CaMeL Defn ( ) != struct CaMeL Defn ) throw new Property CaMeL Value CaMeL Exception ( element . get CaMeL Element ( ) , prop CaMeL Defn , item , Property CaMeL Value CaMeL Exception . DESIGN _ EXCEPTION _ WRONG _ ITEM _ TYPE ) ; ret CaMeL List . add ( do CaMeL Validate CaMeL Structure ( element , struct CaMeL Defn , item ) ) ; } return ret CaMeL List ; }	I CaMeL Property CaMeL Defn tmp CaMeL Prop CaMeL Defn = prop CaMeL Defn ; if ( member CaMeL Defn != null ) tmp CaMeL Prop CaMeL Defn = member CaMeL Defn ; assert tmp CaMeL Prop CaMeL Defn . is CaMeL List ( ) ;
SVN CaMeL Client CaMeL Exception . wrap CaMeL Exception ( e ) ; <CTX> private void diff ( String old CaMeL Path , SVN CaMeL Revision old CaMeL Path CaMeL Revision , String new CaMeL Path , SVN CaMeL Revision new CaMeL Path CaMeL Revision , File out CaMeL File , boolean recurse ) { if ( new CaMeL Path == null ) new CaMeL Path = old CaMeL Path ; if ( old CaMeL Path CaMeL Revision == null ) old CaMeL Path CaMeL Revision = SVN CaMeL Revision . BASE ; if ( new CaMeL Path CaMeL Revision == null ) new CaMeL Path CaMeL Revision = SVN CaMeL Revision . WORKING ; try { Input CaMeL Stream is = _ cmd . diff ( old CaMeL Path , to CaMeL String ( old CaMeL Path CaMeL Revision ) , new CaMeL Path , to CaMeL String ( new CaMeL Path CaMeL Revision ) , recurse ) ; stream CaMeL To CaMeL File ( is , out CaMeL File ) ; } catch ( IO CaMeL Exception e ) { / / this should never happen } catch ( Cmd CaMeL Line CaMeL Exception e ) { SVN CaMeL Client CaMeL Exception . wrap CaMeL Exception ( e ) ; } }	throw SVN CaMeL Client CaMeL Exception . wrap CaMeL Exception ( e ) ;
init _ properties ( ) ; <CTX> public static String get CaMeL Property ( String property ) { if ( secman != null ) secman . check CaMeL Property CaMeL Access ( property ) ; init _ properties ( ) ; return properties . get CaMeL Property ( property ) ; }	if ( properties == null ) init _ properties ( ) ;
get CaMeL X CaMeL Path CaMeL Handler ( ) . number ( Integer . parse CaMeL Int ( token . get CaMeL Token CaMeL Text ( ) ) ) ; <CTX> void number CaMeL Integer ( ) throws org . jaxen . saxpath . SAX CaMeL Path CaMeL Exception { Token token = match ( INTEGER ) ; get CaMeL X CaMeL Path CaMeL Handler ( ) . number ( Integer . parse CaMeL Int ( token . get CaMeL Token CaMeL Text ( ) ) ) ; }	String text = token . get CaMeL Token CaMeL Text ( ) ; try { get CaMeL X CaMeL Path CaMeL Handler ( ) . number ( Integer . parse CaMeL Int ( text ) ) ; } catch ( Number CaMeL Format CaMeL Exception ex ) { get CaMeL X CaMeL Path CaMeL Handler ( ) . number ( Double . parse CaMeL Double ( text ) ) ; }
reindex ( ) ; <CTX> protected void remove CaMeL Update ( Default CaMeL Document CaMeL Event event ) { reindex ( ) ; super . remove CaMeL Update ( event ) ; }	super . remove CaMeL Update ( event ) ;
return new Simple CaMeL XML CaMeL Element CaMeL Value ( data , class CaMeL Name , options ) ; <CTX> public Simple CaMeL XML CaMeL Element CaMeL Value simplexml _ load _ string ( Env env , @ Not CaMeL Null String data , @ Optional String class CaMeL Name , @ Optional int options ) { return new Simple CaMeL XML CaMeL Element CaMeL Value ( data , class CaMeL Name , options ) ; }	Document CaMeL Builder CaMeL Factory factory = Document CaMeL Builder CaMeL Factory . new CaMeL Instance ( ) ; try { Document CaMeL Builder builder = factory . new CaMeL Document CaMeL Builder ( ) ; Document document = builder . parse ( new Byte CaMeL Array CaMeL Input CaMeL Stream ( data . get CaMeL Bytes ( ) ) ) ; return new Simple CaMeL XML CaMeL Element CaMeL Class ( document . get CaMeL Document CaMeL Element ( ) ) ; } catch ( Exception e ) { log . log ( Level . FINE , L . l ( e . to CaMeL String ( ) ) , e ) ; return Null CaMeL Value . NULL ; }
throw new Return CaMeL Jump ( eval ( i CaMeL Visited . get CaMeL Value CaMeL Node ( ) ) ) ; <CTX> public void visit CaMeL Return CaMeL Node ( Return CaMeL Node i CaMeL Visited ) { throw new Return CaMeL Jump ( eval ( i CaMeL Visited . get CaMeL Value CaMeL Node ( ) ) ) ; }	throw new Return CaMeL Jump ( eval ( i CaMeL Visited . get CaMeL Value CaMeL Node ( ) ) , i CaMeL Visited . get CaMeL Target ( ) ) ;
return null ; <CTX> public static E CaMeL Object resolve ( E CaMeL Object object ) { if ( object != null ) { if ( object . e CaMeL Is CaMeL Proxy ( ) ) return EMF CaMeL Core CaMeL Util . resolve ( Transaction CaMeL Util . get CaMeL Editing CaMeL Domain ( object ) , object ) ; else return object ; } return null ; }	return object ;
boolean modify = false ; <CTX> public void add CaMeL Features ( I CaMeL Target CaMeL Feature [ ] features ) { boolean modify = false ; for ( int i = 0 ; i < features . length ; i ++ ) { String id = features [ i ] . get CaMeL Id ( ) ; if ( f CaMeL Features . contains CaMeL Key ( id ) ) continue ; modify = true ; features [ i ] . set CaMeL Model ( get CaMeL Model ( ) ) ; f CaMeL Features . put ( id , features [ i ] ) ; } if ( is CaMeL Editable ( ) && modify ) fire CaMeL Structure CaMeL Changed ( features , I CaMeL Model CaMeL Changed CaMeL Event . INSERT ) ; }	Array CaMeL List list = new Array CaMeL List ( ) ;
set CaMeL Dom CaMeL Node ( document _ . get CaMeL Html CaMeL Page ( ) ) ; <CTX> public Object get ( final String name , final Scriptable start ) { / / If the Dom CaMeL Node hasn t been set yet then do it now . if ( get CaMeL Dom CaMeL Node CaMeL Or CaMeL Null ( ) == null && document _ != null ) { set CaMeL Dom CaMeL Node ( document _ . get CaMeL Html CaMeL Page ( ) ) ; } Object result = super . get ( name , start ) ; final Window this CaMeL Window = ( Window ) start ; / / If we are in a frameset or have an iframe then this might be a frame name if ( result == NOT _ FOUND ) { final Dom CaMeL Node dom CaMeL Node = this CaMeL Window . get CaMeL Dom CaMeL Node CaMeL Or CaMeL Null ( ) ; if ( dom CaMeL Node != null ) { result = get CaMeL Frame CaMeL By CaMeL Name ( dom CaMeL Node . get CaMeL Page ( ) , name ) ; } } / / See if it is an attempt to access an element directly by name or id if we are emulating IE . if ( result == NOT _ FOUND ) { / / this tests are quite silly and should be removed when custom JS objects have a clean / / way to get the Web CaMeL Client they are running in . final Dom CaMeL Node dom CaMeL Node = this CaMeL Window . get CaMeL Dom CaMeL Node CaMeL Or CaMeL Null ( ) ; if ( dom CaMeL Node != null && dom CaMeL Node . get CaMeL Page ( ) . get CaMeL Web CaMeL Client ( ) . get CaMeL Browser CaMeL Version ( ) . is CaMeL IE ( ) ) { final Element CaMeL Array array = ( Element CaMeL Array ) this CaMeL Window . document _ . jsx CaMeL Function _ get CaMeL Elements CaMeL By CaMeL Name ( name ) ; if ( array . js CaMeL Get _ length ( ) == 1 ) { result = array . get ( 0 , array ) ; } else if ( array . js CaMeL Get _ length ( ) > 1 ) { result = array ; } else { result = this CaMeL Window . document _ . jsx CaMeL Function _ get CaMeL Element CaMeL By CaMeL Id ( name ) ; } } } return result ; }	final Html CaMeL Page html CaMeL Page = document _ . get CaMeL Html CaMeL Page CaMeL Or CaMeL Null ( ) ; if ( html CaMeL Page != null ) { set CaMeL Dom CaMeL Node ( html CaMeL Page ) ; }
return ++ error CaMeL Count > MAX _ ERRORS ? PROCESS _ ABORT : PROCESS _ CONTINUE ; <CTX> protected void add CaMeL Symbols ( IAST CaMeL Translation CaMeL Unit ast ) throws Interrupted CaMeL Exception , Core CaMeL Exception { / / Add in the includes IAST CaMeL Preprocessor CaMeL Include CaMeL Statement [ ] includes = ast . get CaMeL Include CaMeL Directives ( ) ; for ( int i = 0 ; i < includes . length ; ++ i ) { IAST CaMeL Preprocessor CaMeL Include CaMeL Statement include = includes [ i ] ; IAST CaMeL File CaMeL Location source CaMeL Loc = include . get CaMeL File CaMeL Location ( ) ; String source CaMeL Path = source CaMeL Loc != null ? source CaMeL Loc . get CaMeL File CaMeL Name ( ) : ast . get CaMeL File CaMeL Path ( ) ; / / command - line includes I CaMeL Index CaMeL Fragment CaMeL File source CaMeL File = code CaMeL Reader CaMeL Factory . create CaMeL Cached CaMeL File ( index , source CaMeL Path ) ; String dest CaMeL Path = include . get CaMeL Path ( ) ; I CaMeL Index CaMeL Fragment CaMeL File dest CaMeL File = code CaMeL Reader CaMeL Factory . create CaMeL Cached CaMeL File ( index , dest CaMeL Path ) ; index . add CaMeL Include ( source CaMeL File , dest CaMeL File ) ; } / / Add in the macros IAST CaMeL Preprocessor CaMeL Macro CaMeL Definition [ ] macros = ast . get CaMeL Macro CaMeL Definitions ( ) ; for ( int i = 0 ; i < macros . length ; ++ i ) { IAST CaMeL Preprocessor CaMeL Macro CaMeL Definition macro = macros [ i ] ; IAST CaMeL File CaMeL Location source CaMeL Loc = macro . get CaMeL File CaMeL Location ( ) ; if ( source CaMeL Loc == null ) continue ; / / skip built - ins and command line macros String filename = source CaMeL Loc . get CaMeL File CaMeL Name ( ) ; I CaMeL Index CaMeL Fragment CaMeL File source CaMeL File = code CaMeL Reader CaMeL Factory . create CaMeL Cached CaMeL File ( index , filename ) ; index . add CaMeL Macro ( source CaMeL File , macro ) ; } / / Add in the names ast . accept ( new AST CaMeL Visitor ( ) { { should CaMeL Visit CaMeL Names = true ; should CaMeL Visit CaMeL Declarations = true ; } public int visit ( IAST CaMeL Name name ) { try { IAST CaMeL File CaMeL Location name CaMeL Loc = name . get CaMeL File CaMeL Location ( ) ; if ( name CaMeL Loc != null ) index . add CaMeL Name ( code CaMeL Reader CaMeL Factory . create CaMeL Cached CaMeL File ( index , name CaMeL Loc . get CaMeL File CaMeL Name ( ) ) , name ) ; return PROCESS _ CONTINUE ; } catch ( Throwable e ) { C CaMeL Core CaMeL Plugin . log ( e ) ; return ++ error CaMeL Count > MAX _ ERRORS ? PROCESS _ ABORT : PROCESS _ CONTINUE ; } } } ) ; }	return ++ f CaMeL Error CaMeL Count > MAX _ ERRORS ? PROCESS _ ABORT : PROCESS _ CONTINUE ;
return my CaMeL Cached CaMeL Detached CaMeL Type ; <CTX> public Psi CaMeL Type get CaMeL Detached CaMeL Type ( Psi CaMeL Element context ) { if ( my CaMeL Cached CaMeL Detached CaMeL Type != null ) return my CaMeL Cached CaMeL Detached CaMeL Type ; try { my CaMeL Cached CaMeL Detached CaMeL Type = get CaMeL Manager ( ) . get CaMeL Element CaMeL Factory ( ) . create CaMeL Type CaMeL From CaMeL Text ( get CaMeL Text ( ) , context ) ; } catch ( Incorrect CaMeL Operation CaMeL Exception e ) { return get CaMeL Type ( ) ; } return my CaMeL Cached CaMeL Detached CaMeL Type ; }	return type ;
return ( IAST CaMeL Type CaMeL Id [ ] ) Array CaMeL Util . remove CaMeL Nulls ( IAST CaMeL Type CaMeL Id . class , type CaMeL Ids ) ; <CTX> public IAST CaMeL Type CaMeL Id [ ] get CaMeL Exception CaMeL Specification ( ) { if ( type CaMeL Ids == null ) return IAST CaMeL Type CaMeL Id . EMPTY _ TYPEID _ ARRAY ; return ( IAST CaMeL Type CaMeL Id [ ] ) Array CaMeL Util . remove CaMeL Nulls ( IAST CaMeL Type CaMeL Id . class , type CaMeL Ids ) ; }	type CaMeL Ids = ( IAST CaMeL Type CaMeL Id [ ] ) Array CaMeL Util . remove CaMeL Nulls CaMeL After ( IAST CaMeL Type CaMeL Id . class , type CaMeL Ids , type CaMeL Ids CaMeL Pos ) ; return type CaMeL Ids ;
current _ mode = initial _ mode ; <CTX> private static void reset ( ) { if ( ! current _ mode . equals ( initial _ mode ) ) reset CaMeL Display CaMeL Mode ( ) ; current _ mode = initial _ mode ; }	current _ mode = initial _ mode ; }
if ( e . find CaMeL Child ( child . get CaMeL Id ( ) ) == null ) { <CTX> private void add CaMeL Deleted CaMeL Children CaMeL Differences ( Directory CaMeL Entry e , Difference d ) { for ( Entry child : my CaMeL Children ) { if ( e . find CaMeL Child ( child . get CaMeL Id ( ) ) == null ) { d . add CaMeL Child ( child . as CaMeL Deleted CaMeL Difference ( ) ) ; } } }	if ( e . find CaMeL Direct CaMeL Child ( child . get CaMeL Id ( ) ) == null ) {
if ( slot . complex CaMeL Slot CaMeL Flag != 0 ) { <CTX> public Object get ( String name , Scriptable start ) { Slot slot = get CaMeL Named CaMeL Slot ( name ) ; if ( slot == null ) { return Scriptable . NOT _ FOUND ; } if ( slot . complex CaMeL Slot CaMeL Flag != 0 ) { Getter CaMeL Slot gslot = ( Getter CaMeL Slot ) slot ; if ( gslot . getter != null ) { return get CaMeL By CaMeL Getter ( gslot , start ) ; } } return slot . value ; }	if ( slot instanceof Getter CaMeL Slot ) {
if ( child . is CaMeL Requires CaMeL Layout ( ) && ! child . get CaMeL Master ( ) . get CaMeL Style ( ) . is CaMeL Alternate CaMeL Flow ( ) ) { <CTX> private void layout CaMeL Absolute CaMeL Children ( Layout CaMeL Context c ) { List children = get CaMeL Children ( ) ; if ( children . size ( ) > 0 ) { Layout CaMeL State state = c . capture CaMeL Layout CaMeL State ( ) ; for ( int i = 0 ; i < children . size ( ) ; i ++ ) { Layer child = ( Layer ) children . get ( i ) ; if ( child . is CaMeL Requires CaMeL Layout ( ) && ! child . get CaMeL Master ( ) . get CaMeL Style ( ) . is CaMeL Alternate CaMeL Flow ( ) ) { layout CaMeL Absolute CaMeL Child ( c , child ) ; if ( child . get CaMeL Master ( ) . get CaMeL Style ( ) . is CaMeL Avoid CaMeL Page CaMeL Break CaMeL Inside ( ) && child . get CaMeL Master ( ) . crosses CaMeL Page CaMeL Break ( c ) ) { ( ( Block CaMeL Box ) child . get CaMeL Master ( ) ) . set CaMeL Need CaMeL Page CaMeL Clear ( true ) ; child . get CaMeL Master ( ) . detach ( ) ; layout CaMeL Absolute CaMeL Child ( c , child ) ; ( ( Block CaMeL Box ) child . get CaMeL Master ( ) ) . set CaMeL Need CaMeL Page CaMeL Clear ( false ) ; } child . set CaMeL Requires CaMeL Layout ( false ) ; child . finish ( c ) ; } } c . restore CaMeL Layout CaMeL State ( state ) ; } }	if ( child . is CaMeL Requires CaMeL Layout ( ) && ! child . is CaMeL Alternate CaMeL Flow ( ) ) {
return ( ( Integer ) Support . convert ( this , data . get CaMeL Value ( ) , Types . INTEGER , null ) ) . int CaMeL Value ( ) ; <CTX> private int get CaMeL Row CaMeL Stat ( ) throws SQL CaMeL Exception { Col CaMeL Data data = current CaMeL Row [ columns . length - 1 ] ; return ( ( Integer ) Support . convert ( this , data . get CaMeL Value ( ) , Types . INTEGER , null ) ) . int CaMeL Value ( ) ; }	return ( ( Integer ) Support . convert ( this , data , Types . INTEGER , null ) ) . int CaMeL Value ( ) ;
void add ( Color CaMeL Definition desc ) { if ( find CaMeL Color ( desc . get CaMeL Id ( ) ) != null ) return ; colors . add ( desc ) ; <CTX> void add ( Color CaMeL Definition desc ) { if ( find CaMeL Color ( desc . get CaMeL Id ( ) ) != null ) return ; colors . add ( desc ) ; }	void add ( I CaMeL Theme CaMeL Descriptor desc ) { if ( find CaMeL Theme ( desc . get CaMeL Id ( ) ) != null ) { return ; } themes . add ( desc ) ;
if ( result != get CaMeL Parent ( ) ) <CTX> Class CaMeL Loader basic CaMeL Find CaMeL Class CaMeL Loader ( ) { Class [ ] stack = context CaMeL Finder . get CaMeL Class CaMeL Context ( ) ; Class CaMeL Loader result = null ; for ( int i = 1 ; i < stack . length ; i ++ ) { Class CaMeL Loader tmp = stack [ i ] . get CaMeL Class CaMeL Loader ( ) ; if ( stack [ i ] != Context CaMeL Finder . class && tmp != null ) { result = tmp ; break ; } } if ( result != get CaMeL Parent ( ) ) return result ; return null ; }	if ( check CaMeL Class CaMeL Loader ( result ) )
return new Conversion CaMeL Set ( value CaMeL Map . entry CaMeL Set ( ) ) ; <CTX> public Set entry CaMeL Set ( ) { / / TODO : Set . Entry must be wrapped appropriately . . . ? return new Conversion CaMeL Set ( value CaMeL Map . entry CaMeL Set ( ) ) ; }	return new Conversion CaMeL Map CaMeL Entry CaMeL Set ( get CaMeL Runtime ( ) , value CaMeL Map . entry CaMeL Set ( ) ) ;
Method get CaMeL Indexed CaMeL Class CaMeL Adder CaMeL Method ( ) ; <CTX> Method get CaMeL Indexed CaMeL Class CaMeL Adder CaMeL Method ( ) ;	Java CaMeL Method get CaMeL Indexed CaMeL Class CaMeL Adder CaMeL Method ( ) ;
if ( get CaMeL Editor CaMeL Input ( ) instanceof I CaMeL File CaMeL Editor CaMeL Input ) <CTX> private void set CaMeL All CaMeL Input ( File CaMeL Editor CaMeL Input input ) { set CaMeL Input ( input ) ; if ( get CaMeL Editor CaMeL Input ( ) instanceof I CaMeL File CaMeL Editor CaMeL Input ) { set CaMeL Part CaMeL Name ( get CaMeL Editor CaMeL Input ( ) . get CaMeL Name ( ) ) ; } for ( Iterator it = pages . iterator ( ) ; it . has CaMeL Next ( ) ; ) { Object page = it . next ( ) ; if ( page instanceof I CaMeL Report CaMeL Editor CaMeL Page ) { ( ( I CaMeL Report CaMeL Editor CaMeL Page ) page ) . set CaMeL Input ( input ) ; } } }	if ( get CaMeL Editor CaMeL Input ( ) != null )
if ( tvrt . additional CaMeL Interface CaMeL Bounds . length != additional CaMeL Interface CaMeL Bounds . length ) return false ; <CTX> private boolean matching CaMeL Bounds ( Type CaMeL Variable CaMeL Reference CaMeL Type tvrt ) { if ( tvrt . get CaMeL Upper CaMeL Bound ( ) != get CaMeL Upper CaMeL Bound ( ) ) return false ; if ( tvrt . has CaMeL Lower CaMeL Bound ( ) != ( get CaMeL Lower CaMeL Bound ( ) != null ) ) return false ; if ( tvrt . has CaMeL Lower CaMeL Bound ( ) && tvrt . get CaMeL Lower CaMeL Bound ( ) != get CaMeL Lower CaMeL Bound ( ) ) return false ; / / either we both have bounds , or neither of us have bounds if ( ( tvrt . additional CaMeL Interface CaMeL Bounds != null ) != ( additional CaMeL Interface CaMeL Bounds != null ) ) return false ; if ( additional CaMeL Interface CaMeL Bounds != null ) { / / we both have bounds , compare if ( tvrt . additional CaMeL Interface CaMeL Bounds . length != additional CaMeL Interface CaMeL Bounds . length ) return false ; Set a CaMeL And CaMeL Not CaMeL B = new Hash CaMeL Set ( ) ; Set b CaMeL And CaMeL Not CaMeL A = new Hash CaMeL Set ( ) ; for ( int i = 0 ; i < additional CaMeL Interface CaMeL Bounds . length ; i ++ ) { a CaMeL And CaMeL Not CaMeL B . add ( additional CaMeL Interface CaMeL Bounds [ i ] ) ; } for ( int i = 0 ; i < tvrt . additional CaMeL Interface CaMeL Bounds . length ; i ++ ) { b CaMeL And CaMeL Not CaMeL A . add ( tvrt . additional CaMeL Interface CaMeL Bounds [ i ] ) ; } for ( int i = 0 ; i < additional CaMeL Interface CaMeL Bounds . length ; i ++ ) { b CaMeL And CaMeL Not CaMeL A . remove ( additional CaMeL Interface CaMeL Bounds [ i ] ) ; } for ( int i = 0 ; i < tvrt . additional CaMeL Interface CaMeL Bounds . length ; i ++ ) { a CaMeL And CaMeL Not CaMeL B . remove ( tvrt . additional CaMeL Interface CaMeL Bounds [ i ] ) ; } if ( ! ( a CaMeL And CaMeL Not CaMeL B . is CaMeL Empty ( ) && b CaMeL And CaMeL Not CaMeL A . is CaMeL Empty ( ) ) ) return false ; } return true ; }	if ( tvrt CaMeL Bounds . length != additional CaMeL Interface CaMeL Bounds . length ) return false ;
sink . text ( caption ) ; <CTX> protected void table CaMeL Caption ( String caption ) { sink . table CaMeL Caption ( ) ; sink . text ( caption ) ; sink . table CaMeL Caption _ ( ) ; }	text ( caption ) ;
select CaMeL Field . set CaMeL Foreground ( color ) ; <CTX> public void action CaMeL Performed ( Action CaMeL Event e ) { Color color = Style CaMeL Util . random CaMeL Color ( ) ; select CaMeL Field . set CaMeL Foreground ( color ) ; }	select CaMeL Field 1 . set CaMeL Foreground ( color ) ;
. to CaMeL String ( ) ) ) selected CaMeL Resources . add ( current CaMeL File ) ; <CTX> protected void select CaMeL Appropriate CaMeL Folder CaMeL Contents ( I CaMeL Container resource ) { try { I CaMeL Resource [ ] members = resource . members ( ) ; for ( int i = 0 ; i < members . length ; i ++ ) { if ( members [ i ] . get CaMeL Type ( ) == I CaMeL Resource . FILE ) { I CaMeL File current CaMeL File = ( I CaMeL File ) members [ i ] ; if ( has CaMeL Exportable CaMeL Extension ( current CaMeL File . get CaMeL Full CaMeL Path ( ) . to CaMeL String ( ) ) ) selected CaMeL Resources . add ( current CaMeL File ) ; } if ( members [ i ] . get CaMeL Type ( ) == I CaMeL Resource . FOLDER ) { select CaMeL Appropriate CaMeL Folder CaMeL Contents ( ( I CaMeL Container ) members [ i ] ) ; } } } catch ( Core CaMeL Exception e ) { / / don t show children if there are errors -- should at least log this } }	. to CaMeL String ( ) ) ) { selected CaMeL Resources . add ( current CaMeL File ) ; }
VM CaMeL Plain CaMeL Datagram CaMeL Socket CaMeL Impl . connect ( this , addr , port ) ; <CTX> protected void connect ( Inet CaMeL Address addr , int port ) throws Socket CaMeL Exception { VM CaMeL Plain CaMeL Datagram CaMeL Socket CaMeL Impl . connect ( this , addr , port ) ; }	channel . connect ( new Inet CaMeL Socket CaMeL Address ( addr , port ) , 0 ) ;
synchronized ( Abstract CaMeL Tree CaMeL Updater . this ) { if ( my CaMeL Run CaMeL After CaMeL Update != null ) { my CaMeL Run CaMeL After CaMeL Update . run ( ) ; my CaMeL Run CaMeL After CaMeL Update = null ; } <CTX> public void run ( ) { synchronized ( Abstract CaMeL Tree CaMeL Updater . this ) { if ( my CaMeL Run CaMeL After CaMeL Update != null ) { my CaMeL Run CaMeL After CaMeL Update . run ( ) ; my CaMeL Run CaMeL After CaMeL Update = null ; } } }	synchronized ( Abstract CaMeL Tree CaMeL Updater . this ) { if ( my CaMeL Run CaMeL After CaMeL Update != null ) { my CaMeL Run CaMeL After CaMeL Update . run ( ) ; my CaMeL Run CaMeL After CaMeL Update = null ;
number CaMeL Format = new Number CaMeL Formatter ( context . get CaMeL Locale ( ) ) ; <CTX> protected boolean format CaMeL Value ( Object value , String format CaMeL Str , Style CaMeL Design style , String CaMeL Buffer formatted CaMeL Str ) { if ( value == null ) { return false ; } assert style != null && formatted CaMeL Str != null ; assert context . get CaMeL Locale ( ) != null ; if ( ( value instanceof Number ) ) { Number CaMeL Formatter number CaMeL Format ; if ( format CaMeL Str == null || format CaMeL Str . length ( ) == 0 ) { number CaMeL Format = style . get CaMeL Number CaMeL Format CaMeL Object ( ) ; / / initial number - format for the first time if ( number CaMeL Format == null ) { number CaMeL Format = new Number CaMeL Formatter ( context . get CaMeL Locale ( ) ) ; format CaMeL Str = style . get CaMeL Number CaMeL Format ( ) ; if ( format CaMeL Str != null ) { number CaMeL Format . apply CaMeL Pattern ( format CaMeL Str ) ; } style . set CaMeL Number CaMeL Format CaMeL Object ( number CaMeL Format ) ; } else { format CaMeL Str = number CaMeL Format . get CaMeL Pattern ( ) ; } } else / / deal with value - of for text item { number CaMeL Format = new Number CaMeL Formatter ( context . get CaMeL Locale ( ) ) ; number CaMeL Format . apply CaMeL Pattern ( format CaMeL Str ) ; } formatted CaMeL Str . append ( number CaMeL Format . format ( ( ( Number ) value ) . double CaMeL Value ( ) ) ) ; } else if ( value instanceof Date ) { Date CaMeL Formatter date CaMeL Format ; if ( format CaMeL Str == null || format CaMeL Str . length ( ) == 0 ) { date CaMeL Format = style . get CaMeL Date CaMeL Format CaMeL Object ( ) ; / / initial date - format for the first time if ( date CaMeL Format == null ) { date CaMeL Format = new Date CaMeL Formatter ( context . get CaMeL Locale ( ) ) ; format CaMeL Str = style . get CaMeL Date CaMeL Time CaMeL Format ( ) ; if ( format CaMeL Str != null ) { date CaMeL Format . apply CaMeL Pattern ( format CaMeL Str ) ; } style . set CaMeL Date CaMeL Format CaMeL Object ( date CaMeL Format ) ; } else { format CaMeL Str = date CaMeL Format . get CaMeL Pattern ( ) ; } } else / / deal with value - of for text item { date CaMeL Format = new Date CaMeL Formatter ( context . get CaMeL Locale ( ) ) ; date CaMeL Format . apply CaMeL Pattern ( format CaMeL Str ) ; } formatted CaMeL Str . append ( date CaMeL Format . format ( ( Date ) value ) ) ; } else if ( value instanceof String ) { String CaMeL Formatter string CaMeL Format ; if ( format CaMeL Str == null || format CaMeL Str . length ( ) == 0 ) { string CaMeL Format = style . get CaMeL String CaMeL Format CaMeL Object ( ) ; / / initial string - format for the first time if ( string CaMeL Format == null ) { string CaMeL Format = new String CaMeL Formatter ( ) ; / / use default string CaMeL Format string CaMeL Format . set CaMeL Locale ( context . get CaMeL Locale ( ) ) ; / / get format pattern from style format CaMeL Str = style . get CaMeL String CaMeL Format ( ) ; if ( format CaMeL Str != null ) { string CaMeL Format . apply CaMeL Pattern ( format CaMeL Str ) ; } style . set CaMeL String CaMeL Format CaMeL Object ( string CaMeL Format ) ; } else { format CaMeL Str = string CaMeL Format . get CaMeL Pattern ( ) ; } } else / / deal with value - of for text item { string CaMeL Format = new String CaMeL Formatter ( ) ; string CaMeL Format . set CaMeL Locale ( context . get CaMeL Locale ( ) ) ; string CaMeL Format . apply CaMeL Pattern ( format CaMeL Str ) ; } formatted CaMeL Str . append ( string CaMeL Format . format ( value . to CaMeL String ( ) ) ) ; } else { formatted CaMeL Str . append ( value . to CaMeL String ( ) ) ; return false ; } if ( format CaMeL Str == null || format CaMeL Str . length ( ) == 0 ) { return false ; } return true ; }	format CaMeL Str = style . get CaMeL Number CaMeL Format ( ) ;
send CaMeL Unsubscribe CaMeL Event ( this . proxy , this . url ) ; <CTX> public void unsubscribe ( ) { send CaMeL Unsubscribe CaMeL Event ( this . proxy , this . url ) ; }	send CaMeL Unsubscribe CaMeL Event ( m _ proxy , m _ url ) ;
tool CaMeL Tip = new J CaMeL Tool CaMeL Tip ( tool CaMeL Tip CaMeL Text ) ; <CTX> public J CaMeL Tool CaMeL Tip create CaMeL Tool CaMeL Tip ( ) { if ( tool CaMeL Tip == null ) tool CaMeL Tip = new J CaMeL Tool CaMeL Tip ( tool CaMeL Tip CaMeL Text ) ; return tool CaMeL Tip ; }	{ tool CaMeL Tip = new J CaMeL Tool CaMeL Tip ( ) ; tool CaMeL Tip . set CaMeL Tip CaMeL Text ( tool CaMeL Tip CaMeL Text ) ; }
I CaMeL Ruby CaMeL Object [ ] new CaMeL Args = new I CaMeL Ruby CaMeL Object [ count - 1 ] ; System . arraycopy ( args , 1 , new CaMeL Args , 0 , count - 1 ) ; I CaMeL Ruby CaMeL Object next CaMeL Line = io . internal CaMeL Gets ( new CaMeL Args ) ; while ( ! next CaMeL Line . is CaMeL Nil ( ) ) { get CaMeL Runtime ( ) . yield ( next CaMeL Line ) ; next CaMeL Line = io . internal CaMeL Gets ( new CaMeL Args ) ; } io . close ( ) ; <CTX> public I CaMeL Ruby CaMeL Object foreach ( I CaMeL Ruby CaMeL Object [ ] args ) { int count = check CaMeL Argument CaMeL Count ( args , 1 , - 1 ) ; I CaMeL Ruby CaMeL Object filename = args [ 0 ] . convert CaMeL To CaMeL String ( ) ; filename . check CaMeL Safe CaMeL String ( ) ; Ruby CaMeL IO io = ( Ruby CaMeL IO ) Ruby CaMeL File . open ( get CaMeL Runtime ( ) . get CaMeL Classes ( ) . get CaMeL File CaMeL Class ( ) , new I CaMeL Ruby CaMeL Object [ ] { filename } , false ) ; if ( ! io . is CaMeL Nil ( ) && io . is CaMeL Open ( ) ) { I CaMeL Ruby CaMeL Object [ ] new CaMeL Args = new I CaMeL Ruby CaMeL Object [ count - 1 ] ; System . arraycopy ( args , 1 , new CaMeL Args , 0 , count - 1 ) ; I CaMeL Ruby CaMeL Object next CaMeL Line = io . internal CaMeL Gets ( new CaMeL Args ) ; while ( ! next CaMeL Line . is CaMeL Nil ( ) ) { get CaMeL Runtime ( ) . yield ( next CaMeL Line ) ; next CaMeL Line = io . internal CaMeL Gets ( new CaMeL Args ) ; } io . close ( ) ; } return get CaMeL Runtime ( ) . get CaMeL Nil ( ) ; }	try { I CaMeL Ruby CaMeL Object [ ] new CaMeL Args = new I CaMeL Ruby CaMeL Object [ count - 1 ] ; System . arraycopy ( args , 1 , new CaMeL Args , 0 , count - 1 ) ; I CaMeL Ruby CaMeL Object next CaMeL Line = io . internal CaMeL Gets ( new CaMeL Args ) ; while ( ! next CaMeL Line . is CaMeL Nil ( ) ) { get CaMeL Runtime ( ) . yield ( next CaMeL Line ) ; next CaMeL Line = io . internal CaMeL Gets ( new CaMeL Args ) ; } } finally { io . close ( ) ; }
