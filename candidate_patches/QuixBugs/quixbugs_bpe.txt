n = ( n ^ ( n - 1 ) ) ; <CTX> public class BIT@@ COUNT { public static int bitcount ( int n ) { int count = 0 ; while ( n != 0 ) { n = ( n ^ ( n - 1 ) ) ; count ++ ; } return count ; } }	n = ( n & ( n - 1 ) ) ;
while ( true ) { <CTX> public class B@@ READ@@ TH _ FIRST _ SEARCH { public static Set < Node > node@@ s@@ visited = new Hash CaMeL Set < > ( ) ; public static boolean breadth _ first _ search ( Node star@@ tnode , Node go@@ al@@ node ) { Deque < Node > queue = new Array CaMeL Deque < > ( ) ; queue . add CaMeL Last ( star@@ tnode ) ; node@@ s@@ visited . add ( star@@ tnode ) ; while ( true ) { Node node = queue . remove CaMeL First ( ) ; if ( node == go@@ al@@ node ) { return true ; } else { for ( Node successor _ node : node . get CaMeL Successors ( ) ) { if ( ! node@@ s@@ visited . contains ( successor _ node ) ) { queue . add CaMeL First ( successor _ node ) ; node@@ s@@ visited . add ( successor _ node ) ; } } } } return false ; } }	while ( ! queue . is CaMeL Empty ( ) ) {
for ( Integer count : arr ) { <CTX> public class BUC@@ KET@@ SORT { public static Array CaMeL List < Integer > bu@@ ck@@ et@@ sort ( Array CaMeL List < Integer > arr , int k ) { Array CaMeL List < Integer > counts = new Array CaMeL List < Integer > ( Collections . n CaMeL Copies ( k , 0 ) ) ; for ( Integer x : arr ) { counts . set ( x , counts . get ( x ) + 1 ) ; } Array CaMeL List < Integer > sorted _ arr = new Array CaMeL List < Integer > ( $NUMBER$ ) ; int i = 0 ; for ( Integer count : arr ) { / / arr is counts in fixed version sorted _ arr . add CaMeL All ( Collections . n CaMeL Copies ( count , i ) ) ; i ++ ; } return sorted _ arr ; } }	for ( Integer count : counts ) {
for ( Node success@@ or@@ nodes : node . get CaMeL Successors ( ) ) { <CTX> public class DEPTH _ FIRST _ SEARCH { public boolean depth _ first _ search ( Node star@@ tnode , Node go@@ al@@ node ) { Set < Node > node@@ s@@ visited = new Hash CaMeL Set < > ( ) ; class Search { boolean search ( Node node ) { if ( node@@ s@@ visited . contains ( node ) ) { return false ; } else if ( node == go@@ al@@ node ) { return true ; } else { for ( Node success@@ or@@ nodes : node . get CaMeL Successors ( ) ) { if ( search ( success@@ or@@ nodes ) ) { return true ; } } } return false ; } } ; Search s = new Search ( ) ; return s . search ( star@@ tnode ) ; } }	node@@ s@@ visited . add ( node ) ; for ( Node success@@ or@@ nodes : node . get CaMeL Successors ( ) ) {
if ( h@@ are . get CaMeL Successor ( ) == null ) <CTX> public class DETECT _ CYCLE { public static boolean detect _ cycle ( Node node ) { Node h@@ are = node ; Node tor@@ to@@ ise = node ; while ( true ) { if ( h@@ are . get CaMeL Successor ( ) == null ) return false ; tor@@ to@@ ise = tor@@ to@@ ise . get CaMeL Successor ( ) ; h@@ are = h@@ are . get CaMeL Successor ( ) . get CaMeL Successor ( ) ; if ( h@@ are == tor@@ to@@ ise ) return true ; } } }	if ( null == h@@ are || h@@ are . get CaMeL Successor ( ) == null )
while ( lo <= hi ) { <CTX> public class FIND _ FIRST _ IN _ SORTED { public static int find _ first _ in _ sorted ( int [ ] arr , int x ) { int lo = 0 ; int hi = arr . length ; while ( lo <= hi ) { int mid = ( lo + hi ) / $NUMBER$ ; if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) { return mid ; } else if ( x <= arr [ mid ] ) { hi = mid ; } else { lo = mid + 1 ; } } return - 1 ; } }	while ( lo < hi ) {
return bin@@ search ( arr , x , mid , end ) ; <CTX> public class FIND _ IN _ SORTED { public static int bin@@ search ( int [ ] arr , int x , int start , int end ) { if ( start == end ) { return - 1 ; } int mid = start + ( end - start ) / $NUMBER$ ; / / check this is floor division if ( x < arr [ mid ] ) { return bin@@ search ( arr , x , start , mid ) ; } else if ( x > arr [ mid ] ) { return bin@@ search ( arr , x , mid , end ) ; } else { return mid ; } } public static int find _ in _ sorted ( int [ ] arr , int x ) { return bin@@ search ( arr , x , 0 , arr . length ) ; } }	return bin@@ search ( arr , x , mid + 1 , end ) ;
result . add ( flatten ( x ) ) ; } } return result ; } else { return flatten ( arr ) ; } <CTX> public class FL@@ AT@@ TEN { public static Object flatten ( Object arr ) { if ( arr instanceof Array CaMeL List ) { Array CaMeL List n@@ arr = ( Array CaMeL List ) arr ; Array CaMeL List result = new Array CaMeL List ( $NUMBER$ ) ; for ( Object x : n@@ arr ) { if ( x instanceof Array CaMeL List ) { result . add CaMeL All ( ( Array CaMeL List ) flatten ( x ) ) ; } else { result . add ( flatten ( x ) ) ; } } return result ; } else { return flatten ( arr ) ; } } }	result . add ( ( x ) ) ; } } return result ; } else { return arr ; }
return gcd ( a % b , b ) ; <CTX> public class G@@ CD { public static int gcd ( int a , int b ) { if ( b == 0 ) { return a ; } else { return gcd ( a % b , b ) ; } } }	return gcd ( b , a % b ) ;
return new Array CaMeL List < Integer > ( ) ; <CTX> public class GET _ FACT@@ ORS { public static Array CaMeL List < Integer > get _ factors ( int n ) { if ( n == 1 ) { return new Array CaMeL List < Integer > ( ) ; } int max = ( int ) ( Math . sqrt ( n ) + 1 . 0 ) ; for ( int i = $NUMBER$ ; i < max ; i ++ ) { if ( n % i == 0 ) { Array CaMeL List < Integer > prepend = new Array CaMeL List < Integer > ( 0 ) ; prepend . add ( i ) ; prepend . add CaMeL All ( get _ factors ( n / i ) ) ; return prepend ; } } return new Array CaMeL List < Integer > ( ) ; } }	return new Array CaMeL List < Integer > ( Arrays . as CaMeL List ( n ) ) ;
steps . add ( new Pair < Integer , Integer > ( start , helper ) ) ; <CTX> public class HAN@@ OI { public static List < Pair < Integer , Integer >> han@@ oi ( int height , int start , int end ) { Array CaMeL List < Pair < Integer , Integer >> steps = new Array CaMeL List < Pair < Integer , Integer >> ( ) ; if ( height > 0 ) { Priority CaMeL Queue < Integer > c@@ rap _ set = new Priority CaMeL Queue < Integer > ( ) ; c@@ rap _ set . add ( 1 ) ; c@@ rap _ set . add ( $NUMBER$ ) ; c@@ rap _ set . add ( $NUMBER$ ) ; c@@ rap _ set . remove ( start ) ; c@@ rap _ set . remove ( end ) ; int helper = c@@ rap _ set . poll ( ) ; steps . add CaMeL All ( han@@ oi ( height - 1 , start , helper ) ) ; steps . add ( new Pair < Integer , Integer > ( start , helper ) ) ; steps . add CaMeL All ( han@@ oi ( height - 1 , helper , end ) ) ; } return steps ; } public static class Pair < F , S > { private F first ; private S second ; public Pair ( F first , S second ) { this . first = first ; this . second = second ; } public void set CaMeL First ( F first ) { this . first = first ; } public void set CaMeL Second ( S second ) { this . second = second ; } public F get CaMeL First ( ) { return first ; } public S get CaMeL Second ( ) { return second ; } @ Override public String to CaMeL String ( ) { return $STRING$ + String . value CaMeL Of ( first ) + $STRING$ + String . value CaMeL Of ( second ) + $STRING$ ; } } }	steps . add ( new Pair < Integer , Integer > ( start , end ) ) ;
return true ; <CTX> public class IS _ VALID _ PARENTHE@@ SIZ@@ ATION { public static Boolean is _ valid _ parenthe@@ siz@@ ation ( String parens ) { int depth = 0 ; for ( int i = 0 ; i < parens . length ( ) ; i ++ ) { Character paren = parens . char CaMeL At ( i ) ; if ( paren . equals ( $STRING$ ) ) { depth ++ ; } else { depth -- ; if ( depth < 0 ) { return false ; } } } return true ; } }	return depth == 0 ;
for ( Integer x : arr ) { <CTX> public class K@@ HE@@ AP@@ SORT { public static Array CaMeL List < Integer > k@@ heap@@ sort ( Array CaMeL List < Integer > arr , int k ) { Priority CaMeL Queue < Integer > heap = new Priority CaMeL Queue < Integer > ( ) ; for ( Integer v : arr . sub CaMeL List ( 0 , k ) ) { heap . add ( v ) ; } Array CaMeL List < Integer > output = new Array CaMeL List < Integer > ( ) ; for ( Integer x : arr ) { heap . add ( x ) ; Integer popped = heap . poll ( ) ; output . add ( popped ) ; } while ( ! heap . is CaMeL Empty ( ) ) { output . add ( heap . poll ( ) ) ; } return output ; } }	for ( Integer x : arr . sub CaMeL List ( k , arr . size ( ) ) ) {
else if ( weight < j ) { <CTX> public class K@@ N@@ AP@@ S@@ ACK { public static int kn@@ ap@@ s@@ ack ( int capacity , int [ ] [ ] items ) { int weight = 0 , value = 0 ; int n = items . length ; int memo [ ] [ ] = new int [ n + 1 ] [ capacity + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { if ( i - 1 >= 0 ) { weight = items [ i - 1 ] [ 0 ] ; value = items [ i - 1 ] [ 1 ] ; } for ( int j = 0 ; j <= capacity ; j ++ ) { if ( i == 0 || j == 0 ) { memo [ i ] [ j ] = 0 ; } else if ( weight < j ) { memo [ i ] [ j ] = Math . max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ; } else { memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ; } } } return memo [ n ] [ capacity ] ; } }	else if ( weight <= j ) {
return kth ( above , k ) ; <CTX> public class K@@ TH { public static Integer kth ( Array CaMeL List < Integer > arr , int k ) { int pivot = arr . get ( 0 ) ; Array CaMeL List < Integer > below , above ; below = new Array CaMeL List < Integer > ( arr . size ( ) ) ; above = new Array CaMeL List < Integer > ( arr . size ( ) ) ; for ( Integer x : arr ) { if ( x < pivot ) { below . add ( x ) ; } else if ( x > pivot ) { above . add ( x ) ; } } int num _ less = below . size ( ) ; int num _ less@@ o@@ req = arr . size ( ) - above . size ( ) ; if ( k < num _ less ) { return kth ( below , k ) ; } else if ( k >= num _ less@@ o@@ req ) { return kth ( above , k ) ; } else { return pivot ; } } }	return kth ( above , k - num _ less@@ o@@ req ) ;
if ( dp . contains CaMeL Key ( i - 1 ) ) { Map < Integer , Integer > internal _ map = dp . get ( i ) ; int insert _ value = dp . get ( i - 1 ) . get ( j ) + 1 ; <CTX> public class LCS _ LENGTH { public static Integer lcs _ length ( String s , String t ) { Map < Integer , Map < Integer , Integer >> dp = new Hash CaMeL Map < Integer , Map < Integer , Integer >> ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { Map < Integer , Integer > initialize = new Hash CaMeL Map < Integer , Integer > ( ) ; dp . put ( i , initialize ) ; for ( int j = 0 ; j < t . length ( ) ; j ++ ) { Map < Integer , Integer > internal _ map = dp . get ( i ) ; internal _ map . put ( j , 0 ) ; dp . put ( i , internal _ map ) ; } } for ( int i = 0 ; i < s . length ( ) ; i ++ ) { for ( int j = 0 ; j < t . length ( ) ; j ++ ) { if ( s . char CaMeL At ( i ) == t . char CaMeL At ( j ) ) { if ( dp . contains CaMeL Key ( i - 1 ) ) { Map < Integer , Integer > internal _ map = dp . get ( i ) ; int insert _ value = dp . get ( i - 1 ) . get ( j ) + 1 ; internal _ map . put ( j , insert _ value ) ; dp . put ( i , internal _ map ) ; } else { Map < Integer , Integer > internal _ map = dp . get ( i ) ; internal _ map . put ( j , 1 ) ; dp . put ( i , internal _ map ) ; } } } } if ( ! dp . is CaMeL Empty ( ) ) { List < Integer > ret _ list = new Array CaMeL List < Integer > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { ret _ list . add ( ! dp . get ( i ) . is CaMeL Empty ( ) ? Collections . max ( dp . get ( i ) . values ( ) ) : 0 ) ; } return Collections . max ( ret _ list ) ; } else { return 0 ; } } }	if ( dp . contains CaMeL Key ( i - 1 ) && dp . get ( i - 1 ) . contains CaMeL Key ( j - 1 ) ) { Map < Integer , Integer > internal _ map = dp . get ( i ) ; int insert _ value = dp . get ( i - 1 ) . get ( j - 1 ) + 1 ;
return 1 + lev@@ enshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ; <CTX> public class LE@@ VEN@@ SH@@ TE@@ IN { public static int lev@@ enshtein ( String source , String target ) { if ( source . is CaMeL Empty ( ) || target . is CaMeL Empty ( ) ) { return source . is CaMeL Empty ( ) ? target . length ( ) : source . length ( ) ; } else if ( source . char CaMeL At ( 0 ) == target . char CaMeL At ( 0 ) ) { return 1 + lev@@ enshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ; } else { return 1 + Math . min ( Math . min ( lev@@ enshtein ( source , target . substring ( 1 ) ) , lev@@ enshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ) , lev@@ enshtein ( source . substring ( 1 ) , target ) ) ; } } }	return lev@@ enshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ;
longest = length + 1 ; <CTX> public class LIS { public static int lis ( int [ ] arr ) { Map < Integer , Integer > ends = new Hash CaMeL Map < Integer , Integer > ( $NUMBER$ ) ; int longest = 0 ; int i = 0 ; for ( int val : arr ) { Array CaMeL List < Integer > prefix _ lengths = new Array CaMeL List < Integer > ( $NUMBER$ ) ; for ( int j = 1 ; j < longest + 1 ; j ++ ) { if ( arr [ ends . get ( j ) ] < val ) { prefix _ lengths . add ( j ) ; } } int length = ! prefix _ lengths . is CaMeL Empty ( ) ? Collections . max ( prefix _ lengths ) : 0 ; if ( length == longest || val < arr [ ends . get ( length + 1 ) ] ) { ends . put ( length + 1 , i ) ; longest = length + 1 ; } i ++ ; } return longest ; } }	longest = Math . max ( longest , length + 1 ) ;
return a . char CaMeL At ( 0 ) + longest _ common _ subsequence ( a . substring ( 1 ) , b ) ; <CTX> public class LONG@@ EST _ COMMON _ SUB@@ SEQUENCE { public static String longest _ common _ subsequence ( String a , String b ) { if ( a . is CaMeL Empty ( ) || b . is CaMeL Empty ( ) ) { return $STRING$ ; } else if ( a . char CaMeL At ( 0 ) == b . char CaMeL At ( 0 ) ) { return a . char CaMeL At ( 0 ) + longest _ common _ subsequence ( a . substring ( 1 ) , b ) ; } else { String fst = longest _ common _ subsequence ( a , b . substring ( 1 ) ) ; String snd = longest _ common _ subsequence ( a . substring ( 1 ) , b ) ; return fst . length ( ) >= snd . length ( ) ? fst : snd ; } } }	return a . char CaMeL At ( 0 ) + longest _ common _ subsequence ( a . substring ( 1 ) , b . substring ( 1 ) ) ;
max _ ending _ here = max _ ending _ here + x ; <CTX> public class MAX _ SUB@@ LIST _ SUM { public static int max _ sublist _ sum ( int [ ] arr ) { int max _ ending _ here = 0 ; int max _ so _ far = 0 ; for ( int x : arr ) { max _ ending _ here = max _ ending _ here + x ; max _ so _ far = Math . max ( max _ so _ far , max _ ending _ here ) ; } return max _ so _ far ; } }	max _ ending _ here = Math . max ( 0 , max _ ending _ here + x ) ;
if ( arr . size ( ) == 0 ) <CTX> public class MER@@ G@@ ES@@ ORT { public static Array CaMeL List < Integer > merge ( Array CaMeL List < Integer > left , Array CaMeL List < Integer > right ) { Array CaMeL List < Integer > result = new Array CaMeL List < Integer > ( $NUMBER$ ) ; int i = 0 ; int j = 0 ; while ( i < left . size ( ) && j < right . size ( ) ) { if ( left . get ( i ) <= right . get ( j ) ) { result . add ( left . get ( i ) ) ; i ++ ; } else { result . add ( right . get ( j ) ) ; j ++ ; } } result . add CaMeL All ( left . sub CaMeL List ( i , left . size ( ) ) . is CaMeL Empty ( ) ? right . sub CaMeL List ( j , right . size ( ) ) : left . sub CaMeL List ( i , left . size ( ) ) ) ; return result ; } public static Array CaMeL List < Integer > mergesort ( Array CaMeL List < Integer > arr ) { if ( arr . size ( ) == 0 ) { return arr ; } else { int middle = arr . size ( ) / $NUMBER$ ; Array CaMeL List < Integer > left = new Array CaMeL List < Integer > ( $NUMBER$ ) ; left . add CaMeL All ( arr . sub CaMeL List ( 0 , middle ) ) ; left = mergesort ( left ) ; Array CaMeL List < Integer > right = new Array CaMeL List < Integer > ( $NUMBER$ ) ; right . add CaMeL All ( arr . sub CaMeL List ( middle , arr . size ( ) ) ) ; right = mergesort ( right ) ; return merge ( left , right ) ; } } }	if ( arr . size ( ) <= 1 )
group CaMeL By CaMeL Node = update ( group CaMeL By CaMeL Node , node , vertex _ u ) ; <CTX> public class MINIMUM _ SP@@ AN@@ NING _ TREE { public static Set < Weighted CaMeL Edge > minimum _ span@@ ning _ tree ( List < Weighted CaMeL Edge > weighted CaMeL Edges ) { Map < Node , Set < Node >> group CaMeL By CaMeL Node = new Hash CaMeL Map < > ( ) ; Set < Weighted CaMeL Edge > min CaMeL Spanning CaMeL Tree = new Hash CaMeL Set < > ( ) ; Collections . sort ( weighted CaMeL Edges ) ; for ( Weighted CaMeL Edge edge : weighted CaMeL Edges ) { Node vertex _ u = edge . node 1 ; Node vertex _ v = edge . node $NUMBER$ ; if ( ! group CaMeL By CaMeL Node . contains CaMeL Key ( vertex _ u ) ) { group CaMeL By CaMeL Node . put ( vertex _ u , new Hash CaMeL Set < > ( Arrays . as CaMeL List ( vertex _ u ) ) ) ; } if ( ! group CaMeL By CaMeL Node . contains CaMeL Key ( vertex _ v ) ) { group CaMeL By CaMeL Node . put ( vertex _ v , new Hash CaMeL Set < > ( Arrays . as CaMeL List ( vertex _ v ) ) ) ; } if ( group CaMeL By CaMeL Node . get ( vertex _ u ) != group CaMeL By CaMeL Node . get ( vertex _ v ) ) { min CaMeL Spanning CaMeL Tree . add ( edge ) ; group CaMeL By CaMeL Node = update ( group CaMeL By CaMeL Node , vertex _ u , vertex _ v ) ; for ( Node node : group CaMeL By CaMeL Node . get ( vertex _ v ) ) { group CaMeL By CaMeL Node = update ( group CaMeL By CaMeL Node , node , vertex _ u ) ; } } } return min CaMeL Spanning CaMeL Tree ; } public static Map < Node , Set < Node >> update ( Map < Node , Set < Node >> group CaMeL By CaMeL Node , Node vertex _ u , Node vertex _ v ) { Set < Node > vertex _ u _ span = new Hash CaMeL Set < > ( group CaMeL By CaMeL Node . get ( vertex _ u ) ) ; vertex _ u _ span . add CaMeL All ( group CaMeL By CaMeL Node . get ( vertex _ v ) ) ; group CaMeL By CaMeL Node . put ( vertex _ u , vertex _ u _ span ) ; return group CaMeL By CaMeL Node ; } }	group CaMeL By CaMeL Node . put ( node , group CaMeL By CaMeL Node . get ( vertex _ u ) ) ;
otherwise . add CaMeL All ( Collections . n CaMeL Copies ( digit _ list . length , 0 ) ) ; <CTX> public class NEXT _ PAL@@ IND@@ RO@@ ME { public static String next _ pal@@ ind@@ ro@@ me ( int [ ] digit _ list ) { int high _ mid = Math . floor CaMeL Div ( digit _ list . length , $NUMBER$ ) ; int low _ mid = Math . floor CaMeL Div ( digit _ list . length - 1 , $NUMBER$ ) ; while ( high _ mid < digit _ list . length && low _ mid >= 0 ) { if ( digit _ list [ high _ mid ] == $NUMBER$ ) { digit _ list [ high _ mid ] = 0 ; digit _ list [ low _ mid ] = 0 ; high _ mid += 1 ; low _ mid -= 1 ; } else { digit _ list [ high _ mid ] += 1 ; if ( low _ mid != high _ mid ) { digit _ list [ low _ mid ] += 1 ; } return Arrays . to CaMeL String ( digit _ list ) ; } } Array CaMeL List < Integer > otherwise = new Array CaMeL List < Integer > ( ) ; otherwise . add ( 1 ) ; otherwise . add CaMeL All ( Collections . n CaMeL Copies ( digit _ list . length , 0 ) ) ; otherwise . add ( 1 ) ; return String . value CaMeL Of ( otherwise ) ; } }	otherwise . add CaMeL All ( Collections . n CaMeL Copies ( digit _ list . length - 1 , 0 ) ) ;
if ( perm . get ( j ) < perm . get ( i ) ) { <CTX> public class NEXT _ PER@@ MUT@@ ATION { public static Array CaMeL List < Integer > next _ permutation ( Array CaMeL List < Integer > perm ) { for ( int i = perm . size ( ) - $NUMBER$ ; i != - 1 ; i -- ) { if ( perm . get ( i ) < perm . get ( i + 1 ) ) { for ( int j = perm . size ( ) - 1 ; j != i ; j -- ) { if ( perm . get ( j ) < perm . get ( i ) ) { Array CaMeL List < Integer > next _ perm = perm ; int temp _ j = perm . get ( j ) ; int temp _ i = perm . get ( i ) ; next _ perm . set ( i , temp _ j ) ; next _ perm . set ( j , temp _ i ) ; Array CaMeL List < Integer > reversed = new Array CaMeL List < Integer > ( $NUMBER$ ) ; for ( int k = next _ perm . size ( ) - 1 ; k != i ; k -- ) { reversed . add ( next _ perm . get ( k ) ) ; } int q = i + 1 ; for ( Integer replace : reversed ) { next _ perm . set ( q , replace ) ; q ++ ; } return next _ perm ; } } } } return new Array CaMeL List < Integer > ( ) ; } }	if ( perm . get ( j ) > perm . get ( i ) ) {
for ( int c = 0 ; c < r ; c ++ ) { <CTX> public class PAS@@ CAL { public static Array CaMeL List < Array CaMeL List < Integer >> pas@@ cal ( int n ) { Array CaMeL List < Array CaMeL List < Integer >> rows = new Array CaMeL List < Array CaMeL List < Integer >> ( ) ; Array CaMeL List < Integer > init = new Array CaMeL List < Integer > ( ) ; init . add ( 1 ) ; rows . add ( init ) ; for ( int r = 1 ; r < n ; r ++ ) { Array CaMeL List < Integer > row = new Array CaMeL List < Integer > ( ) ; for ( int c = 0 ; c < r ; c ++ ) { int up@@ left , up@@ right ; if ( c > 0 ) { up@@ left = rows . get ( r - 1 ) . get ( c - 1 ) ; } else { up@@ left = 0 ; } if ( c < r ) { up@@ right = rows . get ( r - 1 ) . get ( c ) ; } else { up@@ right = 0 ; } row . add ( up@@ left + up@@ right ) ; } rows . add ( row ) ; } return rows ; } }	for ( int c = 0 ; c < r + 1 ; c ++ ) {
if ( total < 0 ) { <CTX> public class POSSIBLE _ CHANGE { public static int possible _ change ( int [ ] coins , int total ) { if ( total == 0 ) { return 1 ; } if ( total < 0 ) { return 0 ; } int first = coins [ 0 ] ; int [ ] rest = Arrays . copy CaMeL Of CaMeL Range ( coins , 1 , coins . length ) ; return possible _ change ( coins , total - first ) + possible _ change ( rest , total ) ; } }	if ( total < 0 || coins . length == 0 ) {
} else if ( x > pivot ) { <CTX> public class QUICK@@ SORT { public static Array CaMeL List < Integer > quicksort ( Array CaMeL List < Integer > arr ) { if ( arr . is CaMeL Empty ( ) ) { return new Array CaMeL List < Integer > ( ) ; } Integer pivot = arr . get ( 0 ) ; Array CaMeL List < Integer > less@@ er = new Array CaMeL List < Integer > ( ) ; Array CaMeL List < Integer > greater = new Array CaMeL List < Integer > ( ) ; for ( Integer x : arr . sub CaMeL List ( 1 , arr . size ( ) ) ) { if ( x < pivot ) { less@@ er . add ( x ) ; } else if ( x > pivot ) { greater . add ( x ) ; } } Array CaMeL List < Integer > middle = new Array CaMeL List < Integer > ( ) ; middle . add ( pivot ) ; less@@ er = quicksort ( less@@ er ) ; greater = quicksort ( greater ) ; middle . add CaMeL All ( greater ) ; less@@ er . add CaMeL All ( middle ) ; return less@@ er ; } }	} else if ( x >= pivot ) {
node = nex@@ tnode ; <CTX> public class REVERSE _ LINKED _ LIST { public static Node reverse _ linked _ list ( Node node ) { Node prev@@ node = null ; Node nex@@ tnode ; while ( node != null ) { nex@@ tnode = node . get CaMeL Successor ( ) ; node . set CaMeL Successor ( prev@@ node ) ; node = nex@@ tnode ; } return prev@@ node ; } }	prev@@ node = node ; node = nex@@ tnode ;
c = bin _ op . apply ( a , b ) ; <CTX> public class R@@ PN _ EVAL { public static Double rpn _ eval ( Array CaMeL List tokens ) { Map < String , Binary CaMeL Operator < Double >> op = new Hash CaMeL Map < String , Binary CaMeL Operator < Double >> ( ) ; op . put ( $STRING$ , ( a , b ) -> a + b ) ; op . put ( $STRING$ , ( a , b ) -> a - b ) ; op . put ( $STRING$ , ( a , b ) -> a * b ) ; op . put ( $STRING$ , ( a , b ) -> a / b ) ; Stack stack = new Stack ( ) ; for ( Object token : tokens ) { if ( Double . class . is CaMeL Instance ( token ) ) { stack . push ( ( Double ) token ) ; } else { token = ( String ) token ; Double a = ( Double ) stack . pop ( ) ; Double b = ( Double ) stack . pop ( ) ; Double c = 0 . 0 ; Binary CaMeL Operator < Double > bin _ op = op . get ( token ) ; c = bin _ op . apply ( a , b ) ; stack . push ( c ) ; } } return ( Double ) stack . pop ( ) ; } }	c = bin _ op . apply ( b , a ) ;
un@@ visited CaMeL Nodes . get ( nex@@ tnode ) + length _ by _ edge . get ( Arrays . as CaMeL List ( node , nex@@ tnode ) ) ) ) ; <CTX> public class SHOR@@ TEST _ PATH _ LENGTH { public int shortest _ path _ length ( Map < List < Node > , Integer > length _ by _ edge , Node star@@ tnode , Node go@@ al@@ node ) { int n = length _ by _ edge . size ( ) ; Map < Node , Integer > un@@ visited CaMeL Nodes = new Hash CaMeL Map < > ( ) ; Set < Node > visited CaMeL Nodes = new Hash CaMeL Set < > ( ) ; un@@ visited CaMeL Nodes . put ( star@@ tnode , 0 ) ; while ( ! un@@ visited CaMeL Nodes . is CaMeL Empty ( ) ) { Node node = get CaMeL Node CaMeL With CaMeL Min CaMeL Distance ( un@@ visited CaMeL Nodes ) ; int distance = un@@ visited CaMeL Nodes . get ( node ) ; un@@ visited CaMeL Nodes . remove ( node ) ; if ( node . get CaMeL Value ( ) == go@@ al@@ node . get CaMeL Value ( ) ) { return distance ; } visited CaMeL Nodes . add ( node ) ; for ( Node nex@@ tnode : node . get CaMeL Successors ( ) ) { if ( visited CaMeL Nodes . contains ( nex@@ tnode ) ) { continue ; } if ( un@@ visited CaMeL Nodes . get ( nex@@ tnode ) == null ) { un@@ visited CaMeL Nodes . put ( nex@@ tnode , Integer . MAX _ VALUE ) ; } un@@ visited CaMeL Nodes . put ( nex@@ tnode , Math . min ( un@@ visited CaMeL Nodes . get ( nex@@ tnode ) , un@@ visited CaMeL Nodes . get ( nex@@ tnode ) + length _ by _ edge . get ( Arrays . as CaMeL List ( node , nex@@ tnode ) ) ) ) ; } } return Integer . MAX _ VALUE ; }	distance + length _ by _ edge . get ( Arrays . as CaMeL List ( node , nex@@ tnode ) ) ) ) ;
length _ by _ path . get ( Arrays . as CaMeL List ( i , k ) ) + length _ by _ path . get ( Arrays . as CaMeL List ( j , k ) ) ) ; <CTX> public class SHOR@@ TEST _ PATH _ LENG@@ THS { final static int INF = $NUMBER$ ; public static Map < List < Integer > , Integer > shortest _ path _ lengths ( int num CaMeL Nodes , Map < List < Integer > , Integer > length _ by _ edge ) { Map < List < Integer > , Integer > length _ by _ path = new Hash CaMeL Map < > ( ) ; for ( int i = 0 ; i < num CaMeL Nodes ; i ++ ) { for ( int j = 0 ; j < num CaMeL Nodes ; j ++ ) { List < Integer > edge = new Array CaMeL List < > ( Arrays . as CaMeL List ( i , j ) ) ; if ( i == j ) { length _ by _ path . put ( edge , 0 ) ; } else if ( length _ by _ edge . contains CaMeL Key ( edge ) ) { length _ by _ path . put ( edge , length _ by _ edge . get ( edge ) ) ; } else { length _ by _ path . put ( edge , INF ) ; } } } for ( int k = 0 ; k < num CaMeL Nodes ; k ++ ) { for ( int i = 0 ; i < num CaMeL Nodes ; i ++ ) { for ( int j = 0 ; j < num CaMeL Nodes ; j ++ ) { int update _ length = Math . min ( length _ by _ path . get ( Arrays . as CaMeL List ( i , j ) ) , length _ by _ path . get ( Arrays . as CaMeL List ( i , k ) ) + length _ by _ path . get ( Arrays . as CaMeL List ( j , k ) ) ) ; length _ by _ path . put ( Arrays . as CaMeL List ( i , j ) , update _ length ) ; } } } return length _ by _ path ; } }	length _ by _ path . get ( Arrays . as CaMeL List ( i , k ) ) + length _ by _ path . get ( Arrays . as CaMeL List ( k , j ) ) ) ;
weight _ by _ edge . put ( edge , update _ weight ) ; <CTX> public class SHOR@@ TEST _ PATHS { final static int INF = $NUMBER$ ; public static Map < String , Integer > shortest _ paths ( String source , Map < List < String > , Integer > weight _ by _ edge ) { Map < String , Integer > weight _ by _ node = new Hash CaMeL Map < String , Integer > ( ) ; for ( List < String > edge : weight _ by _ edge . key CaMeL Set ( ) ) { weight _ by _ node . put ( edge . get ( 1 ) , INF ) ; weight _ by _ node . put ( edge . get ( 0 ) , INF ) ; } weight _ by _ node . put ( source , 0 ) ; for ( int i = 0 ; i < weight _ by _ node . size ( ) ; i ++ ) { for ( List < String > edge : weight _ by _ edge . key CaMeL Set ( ) ) { int update _ weight = Math . min ( weight _ by _ node . get ( edge . get ( 0 ) ) + weight _ by _ edge . get ( edge ) , weight _ by _ node . get ( edge . get ( 1 ) ) ) ; weight _ by _ edge . put ( edge , update _ weight ) ; } } return weight _ by _ node ; }	weight _ by _ node . put ( edge . get ( 1 ) , update _ weight ) ;
} <CTX> public class SH@@ UN@@ TING _ YARD { public static List sh@@ un@@ ting _ y@@ ard ( Array CaMeL List tokens ) { Map < String , Integer > precedence = new Hash CaMeL Map < String , Integer > ( ) ; precedence . put ( $STRING$ , 1 ) ; precedence . put ( $STRING$ , 1 ) ; precedence . put ( $STRING$ , $NUMBER$ ) ; precedence . put ( $STRING$ , $NUMBER$ ) ; Array CaMeL List rp@@ ntokens = new Array CaMeL List ( $NUMBER$ ) ; Array CaMeL Deque op@@ stack = new Array CaMeL Deque ( ) ; for ( Object token : tokens ) { if ( Integer . class . is CaMeL Instance ( token ) ) { rp@@ ntokens . add ( ( Integer ) token ) ; } else { String operator = ( String ) token ; while ( ! op@@ stack . is CaMeL Empty ( ) && precedence . get ( operator ) <= precedence . get ( op@@ stack . get CaMeL Last ( ) ) ) { rp@@ ntokens . add ( op@@ stack . pop ( ) ) ; } } } while ( ! op@@ stack . is CaMeL Empty ( ) ) { rp@@ ntokens . add ( op@@ stack . pop ( ) ) ; } return rp@@ ntokens ; } }	op@@ stack . push ( token ) ; }
if ( any ( list _ comp ( n , primes ) ) ) { <CTX> public class SI@@ E@@ VE { public static boolean all ( Array CaMeL List < Boolean > arr ) { for ( boolean value : arr ) { if ( ! value ) { return false ; } } return true ; } public static boolean any ( Array CaMeL List < Boolean > arr ) { for ( boolean value : arr ) { if ( value ) { return true ; } } return false ; } public static Array CaMeL List < Boolean > list _ comp ( int n , Array CaMeL List < Integer > primes ) { Array CaMeL List < Boolean > built _ comp@@ reh@@ ension = new Array CaMeL List < Boolean > ( ) ; for ( Integer p : primes ) { built _ comp@@ reh@@ ension . add ( n % p > 0 ) ; } return built _ comp@@ reh@@ ension ; } public static Array CaMeL List < Integer > si@@ eve ( Integer max ) { Array CaMeL List < Integer > primes = new Array CaMeL List < Integer > ( ) ; for ( int n = $NUMBER$ ; n < max + 1 ; n ++ ) { if ( any ( list _ comp ( n , primes ) ) ) { primes . add ( n ) ; } } return primes ; } }	if ( all ( list _ comp ( n , primes ) ) ) {
while ( Math . abs ( x - approx ) > epsilon ) { <CTX> public class SQRT { public static double sqrt ( double x , double epsilon ) { double approx = x / $NUMBER$ f ; while ( Math . abs ( x - approx ) > epsilon ) { approx = 0 . $NUMBER$ f * ( approx + x / approx ) ; } return approx ; } }	while ( Math . abs ( x - approx * approx ) > epsilon ) {
return new Array CaMeL List ( ) ; <CTX> public class SUB@@ SEQUENCES { public static Array CaMeL List < Array CaMeL List > sub@@ sequences ( int a , int b , int k ) { if ( k == 0 ) { return new Array CaMeL List ( ) ; } Array CaMeL List ret = new Array CaMeL List ( $NUMBER$ ) ; for ( int i = a ; i < b + 1 - k ; i ++ ) { Array CaMeL List base = new Array CaMeL List ( $NUMBER$ ) ; for ( Array CaMeL List rest : sub@@ sequences ( i + 1 , b , k - 1 ) ) { rest . add ( 0 , i ) ; base . add ( rest ) ; } ret . add CaMeL All ( base ) ; } return ret ; } }	Array CaMeL List empty _ set = new Array CaMeL List < Array CaMeL List > ( ) ; empty _ set . add ( new Array CaMeL List ( ) ) ; return empty _ set ;
result = result + String . value CaMeL Of ( alphabet . char CaMeL At ( i ) ) ; <CTX> public class TO _ BASE { public static String to _ base ( int num , int b ) { String result = $STRING$ ; String alphabet = $STRING$ ; int i ; while ( num > 0 ) { i = num % b ; num = num / b ; result = result + String . value CaMeL Of ( alphabet . char CaMeL At ( i ) ) ; } return result ; } }	result = String . value CaMeL Of ( alphabet . char CaMeL At ( i ) ) + result ;
if ( ordered CaMeL Nodes . contains CaMeL All ( next CaMeL Node . get CaMeL Successors ( ) ) && ! ordered CaMeL Nodes . contains ( next CaMeL Node ) ) { <CTX> public class TOP@@ O@@ LOGICAL _ ORDERING { public static Array CaMeL List < Node > topo@@ logical _ ordering ( List < Node > directed CaMeL Graph ) { Array CaMeL List < Node > ordered CaMeL Nodes = new Array CaMeL List < Node > ( ) ; for ( Node node : directed CaMeL Graph ) { if ( node . get CaMeL Predecessors ( ) . is CaMeL Empty ( ) ) { ordered CaMeL Nodes . add ( node ) ; } } int list CaMeL Size = ordered CaMeL Nodes . size ( ) ; for ( int i = 0 ; i < list CaMeL Size ; i ++ ) { Node node = ordered CaMeL Nodes . get ( i ) ; for ( Node next CaMeL Node : node . get CaMeL Successors ( ) ) { if ( ordered CaMeL Nodes . contains CaMeL All ( next CaMeL Node . get CaMeL Successors ( ) ) && ! ordered CaMeL Nodes . contains ( next CaMeL Node ) ) { ordered CaMeL Nodes . add ( next CaMeL Node ) ; list CaMeL Size ++ ; } } } return ordered CaMeL Nodes ; } }	if ( ordered CaMeL Nodes . contains CaMeL All ( next CaMeL Node . get CaMeL Predecessors ( ) ) && ! ordered CaMeL Nodes . contains ( next CaMeL Node ) ) {
return lines ; <CTX> public class WRAP { public static void main ( String [ ] args ) { System . out . println ( $STRING$ . last CaMeL Index CaMeL Of ( $STRING$ , $NUMBER$ ) ) ; } public static Array CaMeL List < String > wrap ( String text , int cols ) { Array CaMeL List < String > lines = new Array CaMeL List < String > ( ) ; String line ; while ( text . length ( ) > cols ) { int end = text . last CaMeL Index CaMeL Of ( $STRING$ , cols ) ; if ( end == - 1 ) { end = cols ; } line = text . substring ( 0 , end ) ; text = text . substring ( end ) ; lines . add ( line ) ; } return lines ; } }	lines . add ( text ) ; return lines ;
